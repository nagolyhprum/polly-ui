<!doctype html>
<html>
<head>
  <style>
html,
body,
canvas {
  padding: 0;
  border: 0;
  margin: 0;
  background : gray;
}
  </style>
</head>
<body>
  <canvas width="375" height="667" style="background:gray;"></canvas>
  <canvas width="375" height="667" style="background:gray;"></canvas>
<script>

Array.prototype.contains = function(item) {
  return this.indexOf(item) !== -1
}

const LINE_SPACING = 8

function svg(input) {
  const image = new Image()
  image.src = encodeURI(`data:image/svg+xml;,${input}`.replace(/\s+/g, ' '))
  return image
}

const icons_back_white = svg(`
  <svg height="32" width="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path fill="#ffffff" d="M20,11H7.83l5.59,-5.59L12,4l-8,8 8,8 1.41,-1.41L7.83,13H20v-2z"/>
  </svg>
`)

const logos_lexicon_white = svg(`
  <svg width="117" height="114" viewBox="0 0 117 114" xmlns="http://www.w3.org/2000/svg">
      <path fill="#FFFFFF"
          d="M60.8,111.49C91.52,111.49 116.42,86.53 116.42,55.75C116.42,24.96 91.52,0 60.8,0C30.09,0 5.19,24.96 5.19,55.75C5.19,63.71 6.86,71.28 9.86,78.13C12.67,84.55 9.86,103.81 0,112.59C4.89,117.47 31.58,103.65 37.58,106.41C44.65,109.67 52.52,111.49 60.8,111.49Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#DCEFFD"
          d="M61,111C91.65,111 116.5,86.15 116.5,55.5C116.5,24.85 91.65,0 61,0"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#D8D8D8"
          d="M36,46.41a25.35,25.41 0,1 0,50.71 0a25.35,25.41 0,1 0,-50.71 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#2196F3"
          d="M47,46.94a13.9,13.94 0,1 0,27.81 0a13.9,13.94 0,1 0,-27.81 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#FFFFFF"
          d="M52,42.92a4.91,4.92 0,1 0,9.81 0a4.91,4.92 0,1 0,-9.81 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M42,85C47.49,88.94 54.22,91.26 61.49,91.26L61.49,91.26C68.12,91.26 74.31,89.33 79.51,86"
          stroke="#2196F3" stroke-linecap="round"
          stroke-linejoin="round" stroke-width="3"/>
  </svg>`
)

const languages_flag = svg(`
  <svg height="24"
       width="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
      <path fill="#F3625B"
          d="M0,16a16,16 0,1 0,32 0a16,16 0,1 0,-32 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#FFC400"
          d="M16,21.27l-5.56,2.73l1.06,-5.79l-4.5,-4.1l6.22,-0.84l2.78,-5.27l2.78,5.27l6.22,0.84l-4.5,4.1l1.06,5.79z"
          stroke="#00000000" stroke-width="1"/>
      <path fill-opacity="0.2" fill="#000000"
          d="M16,32C24.84,32 32,24.84 32,16C32,7.16 24.84,0 16,0"
          stroke-opacity="0.2" stroke="#00000000" stroke-width="1"/>
  </svg>
`)
const PERCENT = percent => (child, parent, dim) => {
  let other = dim
  switch(other) {
    case 'x' : other = 'width'; break;
    case 'y' : other = 'height'; break;
  }
  return parent[other] * percent / 100;
}
const MATCH = (child, parent, dim) => {
  return parent[dim];
}

function roundRect(context, x, y, width, height, radius, fill, stroke) {
  radius = { tl: radius, tr: radius, br: radius, bl: radius };
  context.beginPath();
  context.moveTo(x + radius.tl, y);
  context.lineTo(x + width - radius.tr, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  context.lineTo(x + width, y + height - radius.br);
  context.quadraticCurveTo(
    x + width,
    y + height,
    x + width - radius.br,
    y + height
  );
  context.lineTo(x + radius.bl, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  context.lineTo(x, y + radius.tl);
  context.quadraticCurveTo(x, y, x + radius.tl, y);
  context.closePath();
  context.fillStyle = fill;
  context.fill();
}

const getValue = (child, parent, dim) => {
  if (typeof child[dim] === "function") {
    return child[dim](child, parent, dim);
  } else {
    return child[dim];
  }
};

const getTopBottom = r => {
  return r ? r[0] + r[2] : 0;
};

const getLeftRight = r => {
  return r ? r[1] + r[3] : 0;
};

function Screen(canvas) {
  this.children = [];
  this.active = this;
  this.canvas = canvas;
  this.bounds = { x : 0, y : 0, width : canvas.width, height : canvas.height}
  this.context = canvas.getContext("2d");
  this.bind();

  const getMouse = (e, name) => {
    const bounds = canvas.getBoundingClientRect();
    return {
      x : e.pageX - bounds.left,
      y : e.pageY - bounds.top,
      name
    }
  }

  this.last = []
  const call = (e, name) => {
    this.mouse = getMouse(e, name);
    let mouseOver = this.render();
    this.last.forEach(view => {
      if(!mouseOver.contains(view)) {
        view.onMouseOut && view.onMouseOut(Object.assign({}, this.mouse, { name : "onMouseOut" }))
      }
    })
    mouseOver.forEach(view => {
      if(!this.last.contains(view)) {
        view.onMouseIn && view.onMouseIn(Object.assign({}, this.mouse, { name : "onMouseIn" }))
      }
    })
    this.last = mouseOver
    let view = mouseOver[mouseOver.length - 1]
    while (view && !view[name]) {
      view = view.parent;
    }
    if(view && view !== this) {
      view[name](this.mouse)
    }
  }

  canvas.onmousedown = e => {
    call(e, "onMouseDown")
  }

  canvas.onmousemove = e => {
    call(e, "onMouseMove")
  }

  canvas.onmouseup = e => {
    call(e, "onMouseUp")
  }

  canvas.onclick = e => {
    call(e, "onClick")
  };
}

Screen.prototype = {
  WRAP: (function() {
    const DIMENSIONS = {
      width : 'x',
      height : 'y',
      x : 'width',
      y : 'height'
    }
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    return function (child, parent, dim) {
      if(child.image) {
        if(child.width === this.WRAP && child.height === this.WRAP) {
          return child.image[dim]
        } else if(dim === 'width' && child.width === this.WRAP && child.height !== this.WRAP) {
          const height = getValue(child, parent, 'height')
          return (height / child.image.height) * child.image.width
        } else if(dim === 'height' && child.width !== this.WRAP && child.height === this.WRAP) {
          const width = getValue(child, parent, 'width')
          return (width / child.image.width) * child.image.height
        }
      } else if (child.children.length) {
        setTimeout(() => {
          const left = (child.margin ? child.margin[3] : 0) + (child.padding ? child.padding[3] : 0)
          const top = (child.margin ? child.margin[0] : 0) + (child.padding ? child.padding[0] : 0)
          const space = (dim === "width" ? getLeftRight(child.padding) + getLeftRight(child.margin) - left : getTopBottom(child.padding) + getTopBottom(child.margin) - top)
          const max = Math.max(...child.children.map(gc => gc.bounds[DIMENSIONS[dim]] + gc.bounds[dim])) - child.bounds[DIMENSIONS[dim]] + space
          if(Math.abs(max - child.bounds[dim]) > 1) {
            child.bounds[dim] = max
            clearTimeout(this.renderTimeout)
            this.renderTimeout = setTimeout(() => {
              this.render()
            })
          }
        })
        return child.bounds[dim]
      } else if (child.text.display) {
        if (dim === "width") {
          context.font = `${child.text.size}px sans-serif`;
          const width = Math.max(...child.text.display.split("\n").map(display => context.measureText(display).width))
          return width + getLeftRight(child.margin) + getLeftRight(child.padding);
        } else if (dim === "height") {
          const count = child.text.display.split("\n").length
          return (
            child.text.size * count + LINE_SPACING * (count - 1) +
            getTopBottom(child.margin) +
            getTopBottom(child.padding)
          );
        }
      }
      return 0
    };
  })(),
  container(width, height, render) {
    const parent = this.active;
    const child = {
      //round
      //margin
      //padding
      //background
      //onClick
      overflow : true,
      parent,
      x: 0,
      y: 0,
      alpha : 1,
      bounds : {
        x : 0,
        y : 0,
        width : 0,
        height : 0
      },
      scrollX : 0,
      scrollY : 0,
      anchorX: 0,
      anchorY: 0,
      width,
      height,
      children: [],
      text: {
        //display
        size: 12,
        color: "black",
        weight : 'normal'
      }
    };
    parent.children.push(child);
    this.active = child;
    render();
    this.active = parent;
  },
  style(text) {
    if(text.size) {
      this.active.text.size = text.size
    }
  },
  position(x, y) {
    this.active.x = x;
    this.active.y = y;
  },
  margin(...margin) {
    if(margin.length === 1) {
      this.active.margin = [margin[0], margin[0], margin[0], margin[0]]
    } else {
      this.active.margin = margin;
    }
  },
  padding(...padding) {
    if(padding.length === 1) {
      this.active.padding = [padding[0], padding[0], padding[0], padding[0]]
    } else {
      this.active.padding = padding;
    }
  },
  background(background) {
    this.active.background = background;
  },
  onClick(onClick) {
    this.active.onClick = onClick;
  },
  text(display) {
    this.active.text.display = display;
  },
  anchor(x, y) {
    this.active.anchorX = x;
    this.active.anchorY = y;
  },
  round(round = true) {
    this.active.round = round;
  },
  shadow(shadow = true) {
    this.active.shadow = shadow;
  },
  center() {
    this.position((_, parent) => parent.width / 2, (_, parent) => parent.height / 2);
    this.anchor(0.5, 0.5);
  },
  src(image) {
    this.active.image = image;
  },
  textColor(textColor) {
    this.active.text.color = textColor
  },
  animate(child, from, to, ms, cb) {
    const start = Date.now()
    const handler = (now = Date.now()) => {
      const percent =  Math.min((now - start) / ms, 1)
      const weight = percent
      Object.keys(from).forEach(key => {
        child[key] = from[key] + (to[key] - from[key]) * weight
      })
      if(percent === 1) {
        clearInterval(interval)
        cb && cb()
      }
      this.render()
    }
    handler(start)
    const interval = setInterval(handler, 1000 / 60)
  },
  start(view, state) {
    this.container(MATCH, MATCH, () => {
      this.background("white")
      view.call(this, state)
    })
    if(this.children.length > 1) {
      this.animate(this.children[this.children.length - 1], {
        alpha : .25,
        x : this.bounds.width
      }, {
        alpha : 1,
        x : 0
      }, 300)
    }
    this.render()
  },
  linear(spacing = 0, direction = 'vertical') {
    this.active.spacing = spacing
    this.active.direction = direction
  },
  back() {
    if(this.children.length > 1) {
      this.animate(this.children[this.children.length - 1], {
        alpha : 1,
        x : 0
      }, {
        alpha : .25,
        x : this.bounds.width
      }, 300, () => {
        this.children.pop()
      })
    } else {
      console.log("TODO")
    }
  },
  render() {
    //console.log("rendering")
    this.context.clearRect(0, 0, this.bounds.width, this.bounds.height)
    return this.children.reduce((mouseOver, child) => mouseOver.concat(this.renderChild(
      { width: this.bounds.width, height: this.bounds.height },
      child
    )), []);
  },
  scrollable() {
    const active = this.active
    active.overflow = false
    let lastMouse, lastTs = Date.now(), dx = 0, dy = 0
    setInterval(() => {
      const now = Date.now()
      const dt = (now - lastTs) / 1000
      lastTs = now
      dx /= 1.2
      if(Math.abs(dx) < 1) {
        dx = 0
      }
      dy /= 1.2
      if(Math.abs(dy) < 1) {
        dy = 0
      }
      if(!lastMouse && (dx || dy)) {
        update()
        this.render()
      }
    }, 1000 / 60)
    const update = () => {
      const right = Math.max(...active.children.map(child => child.bounds.x + child.bounds.width)) - (active.bounds.x + active.bounds.width + active.scrollX)
      const bottom = Math.max(...active.children.map(child => child.bounds.y + child.bounds.height)) - (active.bounds.y + active.bounds.height + active.scrollY)
      active.scrollX = Math.max(Math.min(active.scrollX + dx, 0), -right)
      active.scrollY = Math.max(Math.min(active.scrollY + dy, 0), -bottom)
    }
    active.onMouseMove = function(mouse) {
      if(lastMouse) {
        dx = mouse.x - lastMouse.x
        dy = mouse.y - lastMouse.y
        update()
        lastMouse = mouse
      }
    }
    active.onMouseDown = function(mouse) {
      lastMouse = mouse
    }
    active.onMouseUp = active.onMouseOut = function(mouse) {
      lastMouse = null
    }
  },
  renderChild(parent, child) {
    let mouseOver = []
    this.context.save();
    const width = getValue(child, parent, "width");
    const height = getValue(child, parent, "height");
    const x = getValue(child, parent, "x") - width * child.anchorX;
    const y = getValue(child, parent, "y") - height * child.anchorY;
    const hw = width / 2
    const hh = height / 2
    this.context.translate(x, y);
    const transform = this.context.currentTransform || this.context.getTransform()
    child.bounds.x = transform.e
    child.bounds.y = transform.f
    child.bounds.width = width
    child.bounds.height = height
    const intersection = {
      left : Math.max(child.parent.bounds.x, child.bounds.x),
      top : Math.max(child.parent.bounds.y, child.bounds.y)
    }
    intersection.right = Math.min(child.parent.bounds.x + child.parent.bounds.width, child.bounds.x + child.bounds.width)
    intersection.bottom = Math.min(child.parent.bounds.y + child.parent.bounds.height, child.bounds.y + child.bounds.height)
    const isInBounds = intersection.bottom - intersection.top > 0 && intersection.right - intersection.left > 0
    if(child.hidden) {
      return this.context.restore()
    }
    const margin = child.margin || [0, 0, 0, 0]
    const padding = child.padding || [0, 0, 0, 0]
    this.context.globalAlpha = this.context.globalAlpha * child.alpha
    const mw = width - getLeftRight(margin);
    const mh = height - getTopBottom(margin);
    //DEBUG HERE
    if(true) {
      //padding
      if(padding) {
        this.context.fillStyle = "rgba(0, 255, 0, .7)"
        //top
        this.context.fillRect(margin[3], margin[0], width - (margin[3] + margin[1]), padding[0])
        //left
        this.context.fillRect(margin[3], margin[0] + padding[0], padding[3], height - (margin[0] + margin[2] + padding[0]))
        //right
        this.context.fillRect(width - margin[1] - padding[1], margin[0] + padding[0], padding[1], height - (margin[0] + margin[2] + padding[0]))
        //bottom
        this.context.fillRect(margin[3] + padding[3], height - margin[2] - padding[2], width - (margin[3] + padding[3] + margin[1] + padding[1]), padding[2])
      }
      //margin
      if(margin) {
        this.context.fillStyle = "rgba(0, 0, 255, .7)"
        //top
        this.context.fillRect(0, 0, width, margin[0])
        //left
        this.context.fillRect(0, margin[0], margin[3], height - margin[0])
        //right
        this.context.fillRect(width - margin[1], margin[0], margin[1], height - margin[0])
        //bottom
        this.context.fillRect(margin[3], height - margin[2], width - margin[1] - margin[3], margin[2])
      }
      //outline
      this.context.strokeStyle = "rgba(255, 255, 255, .7)"
      this.context.setLineDash([2, 4])
      this.context.strokeRect(0, 0, width, height)
      this.context.setLineDash([])
    }
    //STOP DEBUG
    this.context.translate(margin[3], margin[0]);
    if(child.shadow) {
      const shadow = 2
      this.context.shadowColor = 'rgba(0, 0, 0, .7)';
      this.context.shadowBlur = shadow;
      this.context.shadowOffsetX = shadow;
      this.context.shadowOffsetY = shadow;
    }
    roundRect(
      this.context,
      0,
      0,
      mw,
      mh,
      child.round ? Math.min(mw, mh) / 2 : 0,
      child.background || "transparent"
    );
    this.context.shadowColor = 'transparent';
    this.context.shadowBlur = 0;
    this.context.shadowOffsetX = 0;
    this.context.shadowOffsetY = 0;
    if(!child.overflow) {
      this.context.clip()
    }
    if (this.mouse && isInBounds && this.context.isPointInPath(this.mouse.x, this.mouse.y)) {
      mouseOver.push(child);
    }
    this.context.translate(padding[3], padding[0]);
    if(child.image && child.image.complete) {
      this.context.drawImage(child.image, 0, 0, mw - getLeftRight(padding), mh - getTopBottom(padding))
    }
    if (child.text.display) {
      this.context.fillStyle = child.text.color;
      this.context.font = `${child.text.size}px sans-serif`;
      this.context.textBaseline = "top";
      this.context.textAlign = "center";
      const lines = child.text.display.split("\n")
      lines.forEach((line, index) => {
        this.context.fillText(
          line,
          mw / 2 - padding[3],
          index * (child.text.size + LINE_SPACING)
        );
      })
    }
    const bounds = {
      width : width - getLeftRight(padding) - getLeftRight(margin),
      height : height - getTopBottom(padding) - getTopBottom(margin)
    }
    this.context.translate(child.scrollX, child.scrollY)
    const direction = child.direction
    const spacing = child.spacing
    child.children.forEach((gc, index) => {
      if(index > 0 && direction) {
        const previous = child.children[index - 1]
        if(direction === 'vertical') {
          gc.y = previous.bounds.y + previous.bounds.height - child.bounds.y + spacing - child.scrollY - padding[0] - margin[0]
        } else if(direction === 'horizontal') {
          gc.x = previous.bounds.x + previous.bounds.width - child.bounds.x + spacing - child.scrollX - padding[3] - margin[3]
        }
      }
      mouseOver = isInBounds ? mouseOver.concat(this.renderChild(bounds, gc)) : this.renderChild(bounds, gc)
      if(index > 0 && direction === 'vertical' && !child.spacing) {
        this.context.beginPath()
        this.context.moveTo(
          gc.bounds.x - child.bounds.x - padding[3] - margin[3],
          gc.bounds.y - child.bounds.y - padding[0] - margin[0]
        )
        this.context.lineTo(
          gc.bounds.x - child.bounds.x + gc.bounds.width - padding[3] - margin[3],
          gc.bounds.y - child.bounds.y - padding[0] - margin[0]
        )
        this.context.strokeStyle = "rgba(0, 0, 0, .7)"
        this.context.stroke()
      }
    });
    this.context.restore();
    return mouseOver
  },
  bind() {
    for (var i in this) {
      if (typeof this[i] === "function") {
        this[i] = this[i].bind(this);
      }
    }
  }
};

const medium_20 = {
  weight : "medium",
  size : 20
}

const bold_34 = {
  weight : "bold",
  size : 34
}
const bold_20 = {
  weight : "bold",
  size : 20
}

const Splash = function (state) {
  const {
    container,
    background,
    padding,
    position,
    text,
    round,
    onClick,
    anchor,
    start,
    src,
    style,
    linear,
    textColor,
    WRAP
  } = this;

  background("#2196f3")
  container(PERCENT(40), WRAP, function () {
    anchor(.5, .5)
    position(PERCENT(50), PERCENT(25))
    src(logos_lexicon_white)
  })
  container(WRAP, WRAP, () => {
    linear(16)
    anchor(.5, .5)
    position(PERCENT(50), PERCENT(50))
    container(WRAP, WRAP, () => {
      anchor(.5, 0)
      position(PERCENT(50), 0)
      textColor("white")
      text("Lexicon")
      style(bold_34)
    })
    container(WRAP, WRAP, () => {
      text("Your language learning buddy")
      textColor("white")
      style(bold_20)
    })
  })
  container(PERCENT(50), WRAP, () => {
    linear(16)
    anchor(.5, .5)
    position(PERCENT(50), PERCENT(75))
    container(MATCH, WRAP, () => {
      padding(16)
      text("GET STARTED")
      textColor("white")
      round()
      background("#673ab7")
      onClick(() => {
        start(LanguagePicker, state)
      })
    })
    container(MATCH, WRAP, () => {
      padding(16)
      text("LOGIN")
      textColor("white")
      onClick(() => {
        console.log("LOGIN")
      })
    })
  })
}

const LANGUAGES = Array.from({ length : 32 }).map((_, i) => ({
  flag : languages_flag,
  display : "Chinese (Mandarin) " + (i + 1)
}))

const LanguagePicker = function(state) {
  const {
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    textColor,
    start
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    container(MATCH, WRAP, () => {
      textColor("white")
      text("What language do\nyou speak natively?")
      anchor(0, .5)
      position(0, PERCENT(50))
      style(medium_20)
    })
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, (child, parent) => parent.height / 2)
      onClick(back)
    })
  })
  const FILL = (child, parent) => parent.height - ((20 * 2 + LINE_SPACING) + (16 * 2) + (16 * 2 + 12) + (16 * 2))
  container(MATCH, FILL, () => {
    background("white")
    shadow()
    linear()
    scrollable()
    LANGUAGES.forEach(language => {
      container(MATCH, WRAP, () => {
        onClick(() => {
          start(GoalPicker, {})
        })
        padding(16)
        linear(16, "horizontal")
        container(WRAP, WRAP, () => {
          src(language.flag)
        })
        container(WRAP, WRAP, () => {
          anchor(0, .5)
          position(0, (child, parent) => parent.height / 2)
          text(language.display)
        })
      })
    })
  })
  container(WRAP, WRAP, () => {
    textColor("white")
    padding(16)
    text("REQUEST A LANGUAGE")
    anchor(1, 0)
    position((child, parent) => parent.width, 0)
  })
}

const GOALS = [{
  months : 15,
  words : 3
}, {
  months : 10,
  words : 6
}, {
  months : 5,
  words : 9
}]

const GoalPicker = function(state) {
  const {
    margin,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    textColor
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    container(MATCH, WRAP, () => {
      textColor("white")
      text("How quickly would you\nlike to learn?")
      anchor(0, .5)
      position(0, PERCENT(50))
      style(medium_20)
    })
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, (child, parent) => parent.height / 2)
      onClick(back)
    })
  })
  container((child, parent) => parent.width / 2, WRAP, () => {
    src(languages_flag)
    position((child, parent) => parent.width / 2, 0)
    anchor(.5, 0)
  })
  container(WRAP, WRAP, () => {
    text("Chinese (Mandarin)")
    textColor("white")
    position((child, parent) => parent.width / 2, 0)
    anchor(.5, 0)
  })
  container(MATCH, WRAP, () => {
    background("white")
    shadow()
    linear()
    GOALS.forEach(goal => {
      container(MATCH, WRAP, () => {
        padding(16)
        linear(8)
        container(WRAP, WRAP, () => {
          text(`I want to be conversational in ${goal.months} months`)
        })
        container(WRAP, WRAP, () => {
          text(`${goal.words} words per day`)
        })
      })
    })
  })
}

new Screen(document.getElementsByTagName("canvas")[0]).start(Splash, {});
new Screen(document.getElementsByTagName("canvas")[1]).start(Splash, {});

</script>
</body>
</html>
