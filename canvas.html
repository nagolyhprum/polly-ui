<!doctype html>
<html>
<head>
  <style>
html,
body,
canvas,
input {
  padding: 0;
  border: 0;
  margin: 0;
}
input {
  background: transparent;
  color: transparent;
  outline: none;
  position : absolute;
  caret-color: black;
  font: 12px sans-serif;
}
  </style>
</head>
<body>
  <canvas width="375" height="667"></canvas>
<script>

const slight_round = 4
const EMPTY_ARRAY = [0, 0, 0, 0]
const COMPLEMENTARY_DIMENSIONS = {
  width : 'x',
  height : 'y',
  x : 'width',
  y : 'height'
}
const OPPOSITE_DIMENSIONS = {
  x : "y",
  y : "x",
  width : "height",
  height : "width"
}
const DIMENSIONS = {
  x : "width",
  y : "height",
  width : "height",
  height : "width"
}
const LINE_SPACING = 8

Array.prototype.contains = function(item) {
  return this.indexOf(item) !== -1
}

function svg(input) {
  const image = new Image()
  image.src = encodeURI(`data:image/svg+xml;,${input}`.replace(/\s+/g, ' '))
  return image
}

const icons_settings = svg(`
  <svg viewBox="0 0 19 20" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="#2196F3" d="M16.759 10.98c.039-.32.068-.64.068-.98 0-.34-.029-.66-.068-.98l2.06-1.65a.513.513 0 0 0 .118-.64l-1.954-3.46c-.117-.22-.381-.3-.595-.22l-2.432 1a7.098 7.098 0 0 0-1.651-.98L11.934.42a.48.48 0 0 0-.479-.42H7.549a.481.481 0 0 0-.479.42l-.371 2.65c-.596.25-1.143.59-1.65.98l-2.432-1a.471.471 0 0 0-.596.22L.068 6.73a.5.5 0 0 0 .117.64l2.061 1.65a8.13 8.13 0 0 0-.069.98c0 .33.03.66.069.98L.185 12.63a.512.512 0 0 0-.117.64l1.953 3.46c.117.22.381.3.596.22l2.432-1c.507.4 1.054.73 1.65.98l.371 2.65c.03.24.235.42.479.42h3.906a.48.48 0 0 0 .479-.42l.371-2.65a7.464 7.464 0 0 0 1.651-.98l2.432 1a.47.47 0 0 0 .595-.22l1.954-3.46a.513.513 0 0 0-.118-.64l-2.06-1.65zM9.5 14C7.57 14 6 12.43 6 10.5S7.57 7 9.5 7 13 8.57 13 10.5 11.43 14 9.5 14z"/></svg>
`)

const download_normal = svg(`
  <svg height="17" viewBox="0 0 14 17" width="14" xmlns="http://www.w3.org/2000/svg"><path fill="#BDBDBD" d="M14 6h-4V0H4v6H0l7 7 7-7zM0 15v2h14v-2H0z"/></svg>
`)

const chapters_possessive = svg(`
  <svg height="48" viewBox="0 0 46 46" width="48" xmlns="http://www.w3.org/2000/svg"><path d="M1 23a22 22 0 1 0 44 0 22 22 0 1 0-44 0z" stroke="#2196F3" stroke-width="2" fill="none"/><path fill="#BBDEFB" d="M15 18a8 8 0 1 1 16 0 8 8 0 1 1-16 0"/><path fill="#2196F3" d="M32.97 23.86c-.59-.66-5.43-3.57-6.46-3.77-1.03-.2-7.98-.91-8.46 0-.47.91.72 1.57 1.17 1.83.44.26 3.08.44 4.82 1.4 1.74.95 1.87 1.57 1.67 2.26-.2.69-1.29 1.82-2.48 1.82-1.18 0-6.27-1.86-6.82-2.25-.54-.4-1.77-2.36-2.11-3.23-.35-.87-.86-3.65-3.26-3.91-2.4-.26.04 4.38.47 5.31.42.92 1.46 4.26 2.18 5.09.72.83 7.18 5 9 5 1.82 0 9.53-.5 10.27-1.17l.01-8.38zM35 24h1a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1h-1a1 1 0 0 1-1-1v-7a1 1 0 0 1 1-1z"/></svg>
`)

const sections_beginner = svg(`
  <svg height="24"
       width="24" viewBox="0 0 107 86" xmlns="http://www.w3.org/2000/svg">
      <path fill="#2196F3"
          d="M53.57,50.15l0,11.4l3.42,0l0,-11.4z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#BBDEFB"
          d="M80.86,19.34C77.18,19.34 74.2,16.36 74.2,12.69C74.2,9.45 76.53,6.75 79.61,6.16C80.92,2.57 84.38,0 88.43,0C92.45,0 95.87,2.51 97.21,6.04C97.22,6.04 97.22,6.04 97.22,6.04C100.9,6.04 103.88,9.02 103.88,12.69C103.88,16.16 101.22,19.01 97.82,19.31L97.82,19.34L80.86,19.34Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#BBDEFB"
          d="M6.97,39.79C3.29,39.79 0.3,36.81 0.3,33.14C0.3,29.9 2.63,27.19 5.71,26.61C7.03,23.02 10.48,20.45 14.54,20.45C18.55,20.45 21.98,22.96 23.32,26.49C23.32,26.49 23.32,26.49 23.32,26.49C27,26.49 29.98,29.47 29.98,33.14C29.98,36.61 27.32,39.46 23.93,39.76L23.93,39.79L6.97,39.79Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#BBDEFB"
          d="M53.57,5.7C53.57,5.7 43.52,15.08 36.47,28.49C29.44,42.85 25.08,54.71 25.08,54.71L53.57,54.71L53.57,5.7Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#2196F3"
          d="M53.57,5.7C53.57,5.7 60.51,21.84 66.11,31.91C72.08,42.41 84.34,56.99 84.34,56.99L53.57,56.99L53.57,5.7Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M21.2,78.7C21.2,78.7 22.68,84.34 27.93,84.34C33.17,84.34 35.27,78.7 35.27,78.7C35.27,78.7 37.23,84.34 42.51,84.34C47.79,84.34 49.64,78.7 49.64,78.7C49.64,78.7 50.91,84.34 56.66,84.34C62.42,84.34 63.91,78.7 63.91,78.7C63.91,78.7 65.78,84.34 71.12,84.34C76.46,84.34 78.09,78.7 78.09,78.7C78.09,78.7 79.93,84.34 85.2,84.34C90.47,84.34 92.08,78.7 92.08,78.7C92.08,78.7 93.07,84.34 98.94,84.34C104.81,84.34 105.53,79 105.53,78.7"
          stroke="#2196F3" stroke-linecap="round"
          stroke-linejoin="round" stroke-width="2"/>
      <path fill="#2196F3"
          d="M53.41,2.59L53.41,5.77L63.85,4.71C64.73,4.62 64.74,4.43 63.87,4.29L53.41,2.59Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#2196F3"
          d="M18.24,61.55L84.92,61.55C88.38,61.55 92.83,63.82 94.87,66.61L100.3,74.09L25.08,74.09L18.24,61.55Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M27.71,68.39L80.35,68.39"
          stroke="#BBDEFB" stroke-linecap="round" stroke-width="2"/>
      <path fill="#00000000"
          d="M83.89,68.39L86.01,68.39"
          stroke="#BBDEFB" stroke-linecap="round" stroke-width="2"/>
  </svg>
`)

const icons_back_white = svg(`
  <svg height="32" width="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path fill="#ffffff" d="M20,11H7.83l5.59,-5.59L12,4l-8,8 8,8 1.41,-1.41L7.83,13H20v-2z"/>
  </svg>
`)

const icons_menu = svg(`
  <svg height="32" width="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="white" d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
`)

const logos_lexicon_white = svg(`
  <svg width="117" height="114" viewBox="0 0 117 114" xmlns="http://www.w3.org/2000/svg">
      <path fill="#FFFFFF"
          d="M60.8,111.49C91.52,111.49 116.42,86.53 116.42,55.75C116.42,24.96 91.52,0 60.8,0C30.09,0 5.19,24.96 5.19,55.75C5.19,63.71 6.86,71.28 9.86,78.13C12.67,84.55 9.86,103.81 0,112.59C4.89,117.47 31.58,103.65 37.58,106.41C44.65,109.67 52.52,111.49 60.8,111.49Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#DCEFFD"
          d="M61,111C91.65,111 116.5,86.15 116.5,55.5C116.5,24.85 91.65,0 61,0"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#D8D8D8"
          d="M36,46.41a25.35,25.41 0,1 0,50.71 0a25.35,25.41 0,1 0,-50.71 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#2196F3"
          d="M47,46.94a13.9,13.94 0,1 0,27.81 0a13.9,13.94 0,1 0,-27.81 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#FFFFFF"
          d="M52,42.92a4.91,4.92 0,1 0,9.81 0a4.91,4.92 0,1 0,-9.81 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M42,85C47.49,88.94 54.22,91.26 61.49,91.26L61.49,91.26C68.12,91.26 74.31,89.33 79.51,86"
          stroke="#2196F3" stroke-linecap="round"
          stroke-linejoin="round" stroke-width="3"/>
  </svg>`
)

const languages_flag = svg(`
  <svg height="24"
       width="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
      <path fill="#F3625B"
          d="M0,16a16,16 0,1 0,32 0a16,16 0,1 0,-32 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#FFC400"
          d="M16,21.27l-5.56,2.73l1.06,-5.79l-4.5,-4.1l6.22,-0.84l2.78,-5.27l2.78,5.27l6.22,0.84l-4.5,4.1l1.06,5.79z"
          stroke="#00000000" stroke-width="1"/>
      <path fill-opacity="0.2" fill="#000000"
          d="M16,32C24.84,32 32,24.84 32,16C32,7.16 24.84,0 16,0"
          stroke-opacity="0.2" stroke="#00000000" stroke-width="1"/>
  </svg>
`)

const streak_normal = svg(`
  <svg height="24"
       width="24" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
      <path fill="#FFFFFF"
          d="M8.877,13.763C11.018,13.763 12.754,12.059 12.754,9.956C12.754,8.805 12.234,7.773 11.412,7.075C9.212,6.036 9.031,4.96 9.031,4.038C8.403,4.713 6.991,5.556 6.991,8.92C6.991,8.92 6.299,8.577 6.167,7.233C5.713,7.668 5,8.889 5,9.956C5,12.059 6.736,13.763 8.877,13.763Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M9,9m-8,0a8,8 0,1 1,16 0a8,8 0,1 1,-16 0"
          stroke="#FFFFFF" stroke-width="1"/>
  </svg>
`)

const slice = function (input) {
  return Array.prototype.slice.call(input)
}

class Observable {
  constructor (value) {
    this.callbacks = []
    this.value = value
  }

  assign (value = {}) {
    this.set(Object.assign({}, this.get(), value))
  }

  observe (callback) {
    this.callbacks.push(callback)
    callback(this.value)
    return callback
  }

  remove (callback) {
    const io = this.callbacks.indexOf(callback)
    if (io !== -1) {
      this.callbacks.splice(io, 1)
    }
  }

  set (value) {
    if (value === this.value) return
    this.value = value
    this.callbacks.forEach(function (callback) {
      callback(value)
    })
  }

  get () {
    return this.value
  }

  static derive () {
    const args = slice(arguments)
    const obs = args.slice(0, args.length - 1)
    const observe = args[args.length - 1]
    const observable$ = new Observable(observe(...obs.map(it => it.get())))
    obs.forEach(function (ob, i) {
      ob.observe(Observable.skipFirst(function (value) {
        const values = obs.map(function (it) {
          return it.get()
        })
        values[i] = value
        observable$.set(observe(...values))
      }))
    })
    return observable$
  }

  static hasValue (hasValue) {
    return function (value) {
      value && hasValue(value)
    }
  }

  static skipFirst (skipFirst) {
    const count = 1// getArgCount(callback)
    let skipped = 0
    return function (...args) {
      if (skipped >= count) {
        return skipFirst(...args)
      }
      skipped++
    }
  }
}

function equals(a, b) {
  if(a === b) {
    return true
  }
  for(var i in a) {
    if(a[i] !== b[i]) {
      return false
    }
  }
  for(var i in b) {
    if(a[i] !== b[i]) {
      return false
    }
  }
  return true
}

function roundRect(context, x, y, width, height, radius, fill, stroke) {
  radius = { tl: radius, tr: radius, br: radius, bl: radius };
  context.beginPath();
  context.moveTo(x + radius.tl, y);
  context.lineTo(x + width - radius.tr, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  context.lineTo(x + width, y + height - radius.br);
  context.quadraticCurveTo(
    x + width,
    y + height,
    x + width - radius.br,
    y + height
  );
  context.lineTo(x + radius.bl, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  context.lineTo(x, y + radius.tl);
  context.quadraticCurveTo(x, y, x + radius.tl, y);
  context.closePath();
  if(fill) {
    context.fillStyle = fill;
    context.fill();
  }
  if(stroke) {
    context.strokeStyle = stroke;
    context.stroke();
  }
}

const getValue = (view, dim) => {
  if (typeof view[dim] === "function") {
    return view[dim](view, dim);
  } else {
    return view[dim];
  }
};

const getTopBottom = r => {
  return r instanceof Array ? r[0] + r[2] : 0;
};

const getLeftRight = r => {
  return r instanceof Array ? r[1] + r[3] : 0;
};

const getName = view => view.text.display || view.image || `(${view.children.map(getName)})`;

const reposition = view => {
  const padding = view.parent.padding instanceof Array ? view.parent.padding : EMPTY_ARRAY
  const margin = view.parent.margin instanceof Array ? view.parent.margin : EMPTY_ARRAY
  return {
    x : view.parent.bounds.x + padding[3] + margin[3] + view.x + (view.parent.scrollX || 0),
    y : view.parent.bounds.y + padding[0] + margin[0] + view.y + (view.parent.scrollY || 0)
  }
}

function Screen(canvas) {

  this.textbox = document.createElement("input")
  document.body.appendChild(this.textbox)
  this.textbox.onblur = e => {
    const view = this.textbox.view
    if(view) {
      this.textbox.view = null
      view.textbox = null
      this.render()
    }
  }
  this.textbox.oninput = e => {
    const view = this.textbox.view
    if(view) {
      view.text.display = this.textbox.value
      this.render()
    }
  }

  this.children = [];
  this.active = this;
  this.canvas = canvas;
  this.bounds = {
    x : 0, y : 0,
    width : canvas.width, height : canvas.height
  }
  this.intersection = {
    left : 0, top : 0, right : canvas.width, bottom : canvas.height,
    x : 0, y : 0, width : canvas.width, height : canvas.height
  }
  this.context = canvas.getContext("2d");
  this.bind();

  const getMouse = (e, name) => {
    const bounds = canvas.getBoundingClientRect();
    return {
      x : e.pageX - bounds.left,
      y : e.pageY - bounds.top,
      name
    }
  }

  this.last = []
  const call = (e, name) => {
    const mouse = getMouse(e, name)
    const mouseOver = this.mouseOver(mouse, this);
    this.last.forEach(view => {
      if(!mouseOver.contains(view)) {
        view.onMouseOut && view.onMouseOut(getMouse(e, "onMouseOut"))
      }
    })
    mouseOver.forEach(view => {
      if(!this.last.contains(view)) {
        view.onMouseIn && view.onMouseIn(getMouse(e, "onMouseIn"))
      }
    })
    this.last = mouseOver
    let view = mouseOver[mouseOver.length - 1]
    while (view && !view[name]) {
      view = view.parent;
    }
    if(view && view !== this) {
      view[name](mouse)
    }
  }

  let moved
  canvas.onmousedown = e => {
    moved = 0
    call(e, "onMouseDown")
  }

  canvas.onmouseout = e => {
    const mouse = getMouse(e, "onMouseOut")
    this.last.forEach(view => {
      view.onMouseOut && view.onMouseOut(mouse)
    })
    this.last = []
  }

  canvas.onmousemove = e => {
    moved++
    call(e, "onMouseMove")
  }

  canvas.onmouseup = e => {
    call(e, "onMouseUp")
  }

  canvas.onclick = e => {
    if(moved < 5) {
      call(e, "onClick")
    }
  };
}

Screen.prototype = {
  mouseOver(mouse, view) {
    return view.children.reduce((mouseOver, child) => {
      const {
        x,
        y,
        width,
        height
      } = child.bounds
      const margin = child.margin || EMPTY_ARRAY
      child.render(
        this.context,
        x + margin[3],
        y + margin[0],
        width - getLeftRight(margin),
        height - getTopBottom(margin),
        getValue(child, "round")
      );
      if (child.isInBounds && this.context.isPointInPath(mouse.x, mouse.y)) {
        return mouseOver.concat([child]).concat(this.mouseOver(mouse, child))
      }
      return mouseOver
    }, [])
  },
  PERCENT(percent) {
    return dim => view => {
      const vp = this.getViewPortSize(view.parent)
      return {
        [dim] : vp[OPPOSITE_DIMENSIONS[DIMENSIONS[dim]]] * percent / 100
      }
    }
  },
  MATCH(dim) {
    return view => {
      const vp = this.getViewPortSize(view.parent)
      switch(dim) {
        case "width" :
           return {
             width : vp.width
           }
        case "height" :
           return {
             height : vp.height
           }
      }
    }
  },
  WRAP: (function() {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    return dim => view => {
      const spaceAround = {
        width : getLeftRight(view.padding) + getLeftRight(view.margin),
        height : getTopBottom(view.padding) + getTopBottom(view.margin)
      }[dim]
      if(view.image) {
        const imageBounds = {
          width : view.image.width || view.image.naturalWidth,
          height : view.image.height || view.image.naturalHeight
        }
        const other = OPPOSITE_DIMENSIONS[dim]
        const opposite = Math.max(0, view.bounds[other] - spaceAround) / imageBounds[other] * imageBounds[dim]
        return {
          [dim] : (opposite || view.image[dim]) + spaceAround
        }
      } else if (view.children.length) {
        return {
          [dim] : Math.max(...view.children.map(
            child =>
              child[COMPLEMENTARY_DIMENSIONS[dim]] + //child.x
              //child.bounds[COMPLEMENTARY_DIMENSIONS[dim]] + //child.bounds.x
              child.bounds[dim] + //child.bounds.width
              spaceAround
          ))
        }
      } else if (view.text.display || view.input) {
        if (dim === "width") {
          context.font = `${view.text.size}px sans-serif`;
          return {
            width : Math.max(...view.text.display.split("\n").map(display => context.measureText(display).width)) + spaceAround
          }
        } else if (dim === "height") {
          const count = view.text.display.split("\n").length
          return {
            height : (
              view.text.size * count + LINE_SPACING * (count - 1) + spaceAround
            )
          }
        }
      }
      return {
        [dim] : spaceAround
      }
    };
  })(),
  container(width, height, render) {
    const parent = this.active;
    const child = {
      render : roundRect,
      round : 0,
      //margin
      //padding
      //background
      //onClick
      managers : [
        typeof width === "function" ? width("width") : () => ({ width }),
        typeof height === "function" ? height("height") : () => ({ height }),
        reposition
      ],
      overflow : true,
      parent,
      alpha : 1,
      x : 0,
      y : 0,
      width : 0,
      height : 0,
      bounds : {
        x : 0,
        y : 0,
        width : 0,
        height : 0
      },
      scrollX : 0,
      scrollY : 0,
      children: [],
      text: {
        //display
        size: 12,
        color: "black",
        weight : 'normal',
        align : "left"
      }
    };
    parent.children.push(child);
    this.active = child;
    render(child);
    this.active = parent;
    return child
  },
  style(text) {
    if(text.size) {
      this.active.text.size = text.size
    }
  },
  getViewPortSize(view) {
    return {
      width : view.bounds.width - getLeftRight(view.padding) - getLeftRight(view.margin),
      height : view.bounds.height - getTopBottom(view.padding) - getTopBottom(view.margin)
    }
  },
  position(x, y) {
    this.active.managers.push(view => {
      const vp = this.getViewPortSize(view.parent)
      return {
        x : vp.width * x,
        y : vp.height * y
      }
    })
  },
  anchor(x, y) {
    this.active.managers.push(view => ({
      x : -Math.max(view.bounds.width, 0) * x,
      y : -Math.max(view.bounds.height, 0) * y
    }))
  },
  visibility(visible) {
    this.active.hidden = !visible
  },
  animateVisibility(visible) {
    const view = this.active
    if(visible) {
      view.hidden = false
      this.animate({
        alpha : view.alpha
      }, {
        alpha : 1
      }, this.firstRender ? 0 : 300)
    } else {
      this.animate({
        alpha : view.alpha
      }, {
        alpha : 0
      }, this.firstRender ? 0 : 300, () => {
        view.hidden = true
      })
    }
  },
  timeout(callback, ms) {
    const active = this.active
    setTimeout(() => {
      this.active = active
      callback()
      this.render()
    }, ms)
  },
  margin(...margin) {
    if(margin.length === 1) {
      this.active.margin = [margin[0], margin[0], margin[0], margin[0]]
    } else {
      this.active.margin = margin;
    }
  },
  padding(...padding) {
    if(padding.length === 1) {
      this.active.padding = [padding[0], padding[0], padding[0], padding[0]]
    } else {
      this.active.padding = padding;
    }
  },
  background(background) {
    this.active.background = background;
  },
  onClick(onClick) {
    this.active.onClick = onClick;
  },
  text(display) {
    this.active.text.display = display;
  },
  round(round) {
    this.active.round = round;
  },
  shadow(shadow = true) {
    this.active.shadow = shadow;
  },
  src(image) {
    this.active.image = image;
  },
  textColor(textColor) {
    this.active.text.color = textColor
  },
  textAlign(align) {
    this.active.text.align = align
  },
  input(input = "text") {
    const view = this.active
    view.input = input
    view.overflow = false
    view.onClick = () => {
      view.textbox = this.textbox
      this.textbox.view = view
      this.textbox.value = view.text.display
      this.textbox.type = input
      this.render()
    }
  },
  animate(from, to, ms, cb) {
    const view = this.active
    const start = Date.now()
    const handler = (now = Date.now()) => {
      const percent =  Math.min((now - start) / ms, 1)
      const weight = percent
      Object.keys(from).forEach(key => {
        view[key] = from[key] + (to[key] - from[key]) * weight
      })
      if(percent === 1) {
        clearInterval(interval)
        cb && cb()
      }
      this.render()
    }
    handler(start)
    const interval = setInterval(handler, 1000 / 60)
  },
  start(view, state) {
    this.firstRender = true
    this.active = this
    this.container(this.MATCH, this.MATCH, () => {
      view.call(this, state)
      if(this.children.length > 1) {
        this.animate({
          alpha : .25,
          x : this.bounds.width
        }, {
          alpha : 1,
          x : 0
        }, 300)
      }
    })
    this.render()
    this.firstRender = false
    return this
  },
  back() {
    if(this.children.length > 1) {
      this.active = this.children[this.children.length - 1]
      this.animate({
        alpha : 1,
        x : 0
      }, {
        alpha : .25,
        x : this.bounds.width
      }, 300, () => {
        this.children.pop()
      })
    } else {
      console.log("TODO")
    }
  },
  separator() {
    this.active.separator = true
  },
  linear(spacing = 0, direction = 'vertical') {
    this.active.managers.unshift(view => {
      const weight = view.children.reduce((weight, child) => weight + (child.weight || 0), 0)
      if(weight) {
        const dim = direction === "vertical" ? "height" : "width"
        const vp = this.getViewPortSize(view)
        const span = view.bounds[dim]
        const space = view.children.reduce((space, child) => {
          return space - (child.weight ? 0 : child.bounds[dim])
        }, vp[dim] - spacing * (view.children.length - 1))
        view.children.forEach(child => {
          if(child.weight) {
            child[dim] = (child.weight / weight) * space
          }
        })
      }
      view.children.forEach((child, index) => {
        if(index) {
          const previous = view.children[index - 1]
          if(direction === 'vertical') {
            child.y = previous.y + previous.bounds.height + spacing
          } else if(direction === 'horizontal') {
            child.x = previous.x + previous.bounds.width + spacing
          }
        }
      })
      return {}
    })
  },
  weight(weight) {
    this.active.weight = weight
  },
  render() {
    this.textbox.style.display = "none"
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
    this.children.forEach(child => {
      this.layoutView(child)
      this.renderView(child)
    });
    const ctx = this.context
    const cvs = this.canvas
    ctx.beginPath()

    ctx.moveTo(0,0)
    ctx.lineTo(cvs.width,0)
    ctx.lineTo(cvs.width,cvs.height)
    ctx.lineTo(0, cvs.height)
    ctx.lineTo(0, 0)

    ctx.moveTo(cvs.width / 4, cvs.height / 4)
    ctx.lineTo(3 * cvs.width / 4, cvs.height / 4)
    ctx.lineTo(3 * cvs.width / 4, 3 * cvs.height / 4)
    ctx.lineTo(cvs.width / 4, 3 * cvs.height / 4)
    ctx.lineTo(cvs.width / 4, cvs.height / 4)
    ctx.fillStyle="rgba(0,0,0,.7)"
    ctx.fill()
  },
  scrollable() {
    const active = this.active
    active.overflow = false
    let lastMouse, lastTs = Date.now(), dx = 0, dy = 0
    setInterval(() => {
      const now = Date.now()
      const dt = (now - lastTs) / 1000
      lastTs = now
      dx /= 1.2
      if(Math.abs(dx) < 1) {
        dx = 0
      }
      dy /= 1.2
      if(Math.abs(dy) < 1) {
        dy = 0
      }
      if(!lastMouse && (dx || dy)) {
        update()
      }
    }, 1000 / 60)
    const update = () => {
      const right = Math.max(0, ...active.children.map(child => child.bounds.x + child.bounds.width - (active.bounds.x + active.bounds.width + active.scrollX)))
      const bottom = Math.max(0, ...active.children.map(child => child.bounds.y + child.bounds.height - (active.bounds.y + active.bounds.height + active.scrollY)))
      active.scrollX = Math.max(Math.min(active.scrollX + dx, 0), -right)
      active.scrollY = Math.max(Math.min(active.scrollY + dy, 0), -bottom)
      this.render()
    }
    active.onMouseMove = function(mouse) {
      if(lastMouse) {
        dx = mouse.x - lastMouse.x
        dy = mouse.y - lastMouse.y
        update()
        lastMouse = mouse
      }
    }
    active.onMouseDown = function(mouse) {
      lastMouse = mouse
    }
    active.onMouseUp = active.onMouseOut = function(mouse) {
      lastMouse = null
    }
  },
  getIntersection(view) {
    const parent = view.parent
    const intersection = {
      x : Math.max(parent.intersection.x, view.bounds.x),
      y : Math.max(parent.intersection.y, view.bounds.y)
    }
    intersection.left = intersection.x
    intersection.top = intersection.y
    intersection.right = Math.min(parent.intersection.x + parent.intersection.width, view.bounds.x + view.bounds.width)
    intersection.bottom = Math.min(parent.intersection.y + parent.intersection.height, view.bounds.y + view.bounds.height)
    intersection.width = intersection.right - intersection.left
    intersection.height = intersection.bottom - intersection.top
    view.intersection = intersection
    //then check if its in bounds
    view.isInBounds = intersection.width > 0 && intersection.height > 0 && !view.hidden
  },
  layoutView(view) {
    const bounds = view.hidden ? {x:0,y:0,width:0,height:0} : view.managers.reduce((bounds, manager) => {
      const wrapper = manager(view)
      const current = typeof wrapper === "function" ? wrapper(view) : wrapper
      return {
        x : Math.round((current.x || 0) + bounds.x),
        y : Math.round((current.y || 0) + bounds.y),
        width : Math.round((current.width || 0) + bounds.width),
        height : Math.round((current.height || 0) + bounds.height)
      }
    }, {
      x : 0,
      y : 0,
      width : view.width,
      height : view.height
    })
    const moved = !equals(view.bounds, bounds)
    view.bounds = bounds
    if(moved) {
      this.layoutView(view)
    } else {
      this.getIntersection(view)
    }
    if(view.children.length) {
      if(view.children.reduce((moved, child) => this.layoutView(child) || moved, false)) {
        this.layoutView(view)
        return true
      }
    }
    return moved
  },
  renderView(view) {
    if(view.isInBounds) {
      this.context.save()
      this.context.globalAlpha = this.context.globalAlpha * view.alpha
      const x = view.bounds.x
      const y = view.bounds.y
      const width = view.bounds.width
      const height = view.bounds.height
      const hw = width / 2
      const hh = height / 2
      const margin = view.margin || EMPTY_ARRAY
      const padding = view.padding || EMPTY_ARRAY
      const mw = width - getLeftRight(margin);
      const mh = height - getTopBottom(margin);

      if(view.shadow) {
        const shadow = 2
        this.context.shadowColor = 'rgba(0, 0, 0, .7)';
        this.context.shadowBlur = shadow;
        this.context.shadowOffsetX = shadow;
        this.context.shadowOffsetY = shadow;
      }
      view.render(
        this.context,
        x + margin[3],
        y + margin[0],
        mw,
        mh,
        getValue(view, "round"),
        view.background || "transparent"
      )
      this.context.shadowColor = 'transparent';
      this.context.shadowBlur = 0;
      this.context.shadowOffsetX = 0;
      this.context.shadowOffsetY = 0;
      //DEBUG HERE
      if(false) {
        this.context.translate(x, y)
        //padding
        if(padding) {
          this.context.fillStyle = "rgba(0, 255, 0, .7)"
          //top
          this.context.fillRect(margin[3], margin[0], width - (margin[3] + margin[1]), padding[0])
          //left
          this.context.fillRect(margin[3], margin[0] + padding[0], padding[3], height - (margin[0] + margin[2] + padding[0]))
          //right
          this.context.fillRect(width - margin[1] - padding[1], margin[0] + padding[0], padding[1], height - (margin[0] + margin[2] + padding[0]))
          //bottom
          this.context.fillRect(margin[3] + padding[3], height - margin[2] - padding[2], width - (margin[3] + padding[3] + margin[1] + padding[1]), padding[2])
        }
        //margin
        if(margin) {
          this.context.fillStyle = "rgba(0, 0, 255, .7)"
          //top
          this.context.fillRect(0, 0, width, margin[0])
          //left
          this.context.fillRect(0, margin[0], margin[3], height - margin[0])
          //right
          this.context.fillRect(width - margin[1], margin[0], margin[1], height - margin[0])
          //bottom
          this.context.fillRect(margin[3], height - margin[2], width - margin[1] - margin[3], margin[2])
        }
        //outline
        this.context.strokeStyle = "rgba(0, 0, 0, .7)"
        this.context.setLineDash([2, 4])
        this.context.strokeRect(0, 0, width, height)
        this.context.setLineDash([])
        this.context.translate(-x, -y)
      }
      if(view.image && view.image.complete) {
        this.context.drawImage(view.image, x + padding[3], y + padding[0], mw - getLeftRight(padding), mh - getTopBottom(padding))
      }
      //STOP DEBUG
      if(!view.overflow) {
        this.context.clip()
      }
      if(view.textbox) {
        view.textbox.style.display = "block"
        view.textbox.style.left = `${view.bounds.x}px`
        view.textbox.style.top = `${view.bounds.y}px`
        view.textbox.style.width = `${view.bounds.width}px`
        view.textbox.style.height = `${view.bounds.height}px`
        if(this.textbox !== document.activeElement) {
          this.textbox.focus()
        }
      }
      if (view.text.display) {
        const offset = view.textbox ? view.textbox.scrollLeft : 0
        this.context.fillStyle = view.text.color;
        this.context.font = `${view.text.size}px sans-serif`;
        this.context.textBaseline = "top";
        this.context.textAlign = view.text.align;
        const lines = view.text.display.split("\n")
        lines.forEach((line, index) => {
          let offsetX = 0
          switch(this.context.textAlign) {
            case "right" : offsetX = width - getLeftRight(padding); break;
            case "center" : offsetX = mw / 2 - padding[3]; break;
          }
          // \u25CF
          // \u2022
          this.context.fillText(
            view.input === "password" ? line.split("").map(it => '\u2022').join("") : line,
            x + offsetX + padding[3] - offset,
            y + index * (view.text.size + LINE_SPACING) + padding[0]
          );
        })
      }
      view.children.forEach((child, index) => {
        this.renderView(child)
        if(index > 0 && view.separator) {
          this.context.beginPath()
          this.context.moveTo(
            child.bounds.x,
            child.bounds.y
          )
          this.context.lineTo(
            child.bounds.x + child.bounds.width,
            child.bounds.y
          )
          this.context.strokeStyle = "rgba(0, 0, 0, .7)"
          this.context.stroke()
        }
      });
      this.context.globalAlpha = this.context.globalAlpha / view.alpha
      this.context.restore()
    }
  },
  button(color) {
    this.textAlign("center")
    this.padding(16)
    this.textColor("white")
    if(color) {
      this.round(child => Math.min(child.bounds.width / 2, child.bounds.height / 2))
      this.background(color)
    }
  },
  card() {
    this.background("white")
    this.round(slight_round)
    this.shadow()
  },
  tabs(...tabs) {
    const tab$ = new Observable(0)
    this.container(this.MATCH, this.WRAP, container => {
      this.container(this.MATCH, this.WRAP, () => {
        this.linear(0, "horizontal")
        tabs.forEach((text, index) => {
          this.container(0, this.WRAP, () => {
            this.textColor(index ? "black" : "white")
            this.padding(16)
            this.weight(1)
            this.text(text)
            this.style(normal_12)
            this.textAlign("center")
            this.onClick(() => tab$.set(index))
          })
        })
      })
      const indicator = this.container(dim => view => ({
        width : view.parent.bounds.width / tabs.length
      }), 5, () => {
        this.position(0, 1)
        this.anchor(0, 1)
        this.background("gold")
      })
      tab$.observe(tab => {
        container.children[0].children.forEach(child => {
          child.text.color = "black"
        })
        container.children[0].children[tab].text.color = "white"
        this.active = indicator
        this.animate({
          x : indicator.x
        }, {
          x : tab * container.bounds.width / tabs.length
        }, 300)
      })
    })
    return tab$
  },
  observe(...args) {
    const observables$ = args
    const callback = observables$.pop()
    const view = this.active
    observables$.forEach((observable$, i) => {
      observable$.observe(Observable.skipFirst(observable => {
        this.active = view
        const values = observables$.map(it => it.get())
        values[i] = observable
        callback(...values)
      }))
    })
    callback(...observables$.map(it => it.get()))
  },
  bind() {
    for (var i in this) {
      if (typeof this[i] === "function") {
        this[i] = this[i].bind(this);
      }
    }
  }
};

const normal_12 = {
  size : 12
}
const medium_20 = {
  weight : "medium",
  size : 20
}
const bold_34 = {
  weight : "bold",
  size : 34
}
const bold_20 = {
  weight : "bold",
  size : 20
}

const Splash = function (state) {
  const {
    container,
    background,
    padding,
    position,
    text,
    round,
    onClick,
    anchor,
    start,
    src,
    style,
    linear,
    textColor,
    WRAP,
    MATCH,
    PERCENT,
    textAlign,
    button
  } = this;
  background("#2196f3")
  container(PERCENT(40), WRAP, () => {
    anchor(.5, .5)
    position(.5, .25)
    src(logos_lexicon_white)
  })
  container(WRAP, WRAP, () => {
    linear(16)
    anchor(.5, .5)
    position(.5, .5)
    container(WRAP, WRAP, () => {
      anchor(.5, 0)
      position(.5, 0)
      textColor("white")
      text("Lexicon")
      style(bold_34)
    })
    container(WRAP, WRAP, () => {
      text("Your language learning buddy")
      textColor("white")
      style(bold_20)
    })
  })
  container(PERCENT(50), WRAP, () => {
    linear(16)
    anchor(.5, .5)
    position(.5, .75)
    container(MATCH, WRAP, () => {
      button("#673ab7")
      text("GET STARTED")
      onClick(() => {
        start(LanguagePicker, state)
      })
    })
    container(MATCH, WRAP, () => {
      text("LOGIN")
      button()
      onClick(() => {
        start(Login)
      })
    })
  })
}

const LANGUAGES = Array.from({ length : 32 }).map((_, i) => ({
  flag : languages_flag,
  display : "Chinese - Mandarin " + (i + 1)
}))

const LanguagePicker = function(state) {
  const {
    round,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    MATCH,
    textColor,
    start,
    textAlign,
    weight,
    button,
    card,
    separator
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    container(MATCH, WRAP, () => {
      textColor("white")
      text("What language do\nyou speak natively?")
      textAlign("center")
      style(medium_20)
    })
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, .5)
      onClick(back)
    })
  })
  container(MATCH, 0, () => {
    weight(1)
    card()
    linear()
    scrollable()
    separator()
    LANGUAGES.forEach((language, index) => {
      container(MATCH, WRAP, () => {
        onClick(() => {
          start(GoalPicker, {})
        })
        padding(16)
        linear(16, "horizontal")
        container(WRAP, WRAP, () => {
          src(language.flag)
        })
        container(WRAP, WRAP, () => {
          text(language.display)
          anchor(0, .5)
          position(0, .5)
        })
      })
    })
  })
  container(WRAP, WRAP, () => {
    text("REQUEST A LANGUAGE")
    button()
    anchor(1, 0)
    position(1, 0)
  })
}

const GOALS = [{
  months : 15,
  words : 3
}, {
  months : 10,
  words : 6
}, {
  months : 5,
  words : 9
}]

const GoalPicker = function(state) {
  const {
    start,
    round,
    margin,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    PERCENT,
    WRAP,
    MATCH,
    textColor,
    textAlign,
    card,
    separator
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    container(MATCH, WRAP, () => {
      textColor("white")
      text("How quickly would you\nlike to learn?")
      textAlign("center")
      anchor(0, .5)
      position(0, .5)
      style(medium_20)
    })
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, .5)
      onClick(back)
    })
  })
  container(PERCENT(40), WRAP, () => {
    src(languages_flag)
    position(.5, 0)
    anchor(.5, 0)
  })
  container(WRAP, WRAP, () => {
    text("Chinese (Mandarin)")
    textColor("white")
    position(.5, 0)
    anchor(.5, 0)
  })
  container(MATCH, WRAP, () => {
    card()
    linear()
    separator()
    GOALS.forEach(goal => {
      container(MATCH, WRAP, () => {
        padding(16)
        linear(8)
        container(WRAP, WRAP, () => {
          text(`I want to be conversational in ${goal.months} months`)
        })
        container(WRAP, WRAP, () => {
          text(`${goal.words} words per day`)
        })
        onClick(() => {
          start(Overview)
        })
      })
    })
  })
}

const Login = function(state) {
  const {
    round,
    margin,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    MATCH,
    textColor,
    textAlign,
    input,
    button,
    card,
    start
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    linear(16, "horizontal")
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, .5)
      onClick(back)
    })
    container(WRAP, WRAP, () => {
      textColor("white")
      text("Login")
      anchor(0, .5)
      position(0, .5)
      style(medium_20)
    })
  })
  container(MATCH, WRAP, () => {
    card()
    padding(16)
    linear(16)
    container(MATCH, WRAP, () => {
      text("Username")
      input()
    })
    container(MATCH, WRAP, () => {
      text("Password")
      input("password")
    })
    container(MATCH, WRAP, () => {
      text("Login")
      button("#673ab7")
      onClick(() => {
        start(Overview)
      })
    })
    container(MATCH, WRAP, () => {
      container(MATCH, 1, () => {
        position(0, .5)
        anchor(0, .5)
        background("black")
      })
      container(WRAP, WRAP, () => {
        position(.5, 0)
        anchor(.5, 0)
        text("OR")
        background("white")
        padding(0, 16, 0, 16)
      })
    })
    container(MATCH, WRAP, () => {
      text("CONNECT WITH GOOGLE")
      button("#673ab7")
      onClick(() => {
        start(Overview)
      })
    })
    container(MATCH, WRAP, () => {
      button("#673ab7")
      text("CONNECT WITH FACEBOOK")
      onClick(() => {
        start(Overview)
      })
    })
  })
}

const CHAPTER = {
  icon : chapters_possessive,
  name : "Possessive",
  description : "To have"
}

const CHAPTERS = [CHAPTER, CHAPTER, CHAPTER]

const SECTION = {
  icon : sections_beginner,
  name : "Beginner",
  chapters : CHAPTERS
}

const SECTIONS = [SECTION, SECTION, SECTION]

const PHRASE = {
  translation : {
    english : "TO OWN",
    mandarin : "you"
  }
}

const PHRASES = {
  a : [PHRASE, PHRASE, PHRASE],
  b : [PHRASE, PHRASE, PHRASE],
  c : [PHRASE, PHRASE, PHRASE]
}

const MENU_ITEM = {
  icon : icons_settings,
  text : "Settings",
  onClick : () => {
    console.log("Settings")
  }
}

const MENU = [MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM, MENU_ITEM]

const Overview = function(state) {
  const {
    round,
    margin,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    MATCH,
    PERCENT,
    textColor,
    textAlign,
    input,
    button,
    card,
    weight,
    separator,
    tab,
    tabs,
    visibility,
    animateVisibility,
    observe,
    timeout,
    animate
  } = this
  const drawer$ = new Observable(false)
  container(MATCH, MATCH, () => {
    background("#2196f3")
    linear(0)
    container(MATCH, WRAP, () => {
      padding(16, 16, 0, 16)
      linear(8, "horizontal")
      container(WRAP, WRAP, () => {
        src(icons_menu)
        onClick(() => {
          drawer$.set(true)
        })
      })
      container(0, WRAP, () => {
        position(0, .5)
        anchor(0, .5)
        weight(1)
        textColor("white")
        text("Chinese - Mandarin")
        style(medium_20)
      })
      container(WRAP, PERCENT(50), () => {
        src(languages_flag)
        position(0, .5)
        anchor(0, .5)
      })
      container(WRAP, WRAP, () => {
        position(0, .5)
        anchor(0, .5)
        textColor("white")
        text("100%")
        style(normal_12)
      })
      container(WRAP, PERCENT(50), () => {
        src(streak_normal)
        position(0, .5)
        anchor(0, .5)
      })
      container(WRAP, WRAP, () => {
        position(0, .5)
        anchor(0, .5)
        textColor("white")
        text("1")
        style(normal_12)
      })
    })
    const tab$ = tabs("LEARN", "REVIEW")
    container(MATCH, 0, () => {
      weight(1)
      container(MATCH, MATCH, () => {
        observe(tab$, tab => {
          animateVisibility(tab === 0)
        })
        linear()
        scrollable()
        background('#f1f9ff')
        SECTIONS.forEach(section => {
          container(MATCH, WRAP, () => {
            padding(16)
            linear(8)
            container(PERCENT(25), WRAP, () => {
              position(.5, 0)
              anchor(.5, 0)
              src(section.icon)
            })
            container(WRAP, WRAP, () => {
              position(.5, 0)
              anchor(.5, 0)
              text(section.name)
            })
          })
          container(MATCH, WRAP, () => {
            card()
            linear()
            separator()
            section.chapters.forEach(chapter => {
              container(MATCH, WRAP, () => {
                onClick(() => {
                  console.log("chapter")
                })
                padding(16)
                linear(16, "horizontal")
                container(WRAP, WRAP, () => {
                  position(0, .5)
                  anchor(0, .5)
                  src(chapter.icon)
                })
                container(0, WRAP, () => {
                  position(0, .5)
                  anchor(0, .5)
                  weight(1)
                  linear(8)
                  container(WRAP, WRAP, () => {
                    text(chapter.name)
                  })
                  container(WRAP, WRAP, () => {
                    text(chapter.description)
                  })
                })
                container(WRAP, WRAP, () => {
                  padding(8)
                  position(0, .5)
                  anchor(0, .5)
                  src(download_normal)
                  onClick(() => {
                    console.log("download")
                  })
                })
              })
            })
          })
        })
      })
      container(MATCH, MATCH, () => {
        background('#f1f9ff')
        observe(tab$, tab => {
          animateVisibility(tab === 1)
        })
        linear()
        container(MATCH, WRAP, () => {
          padding(16)
          background("white")
          container(MATCH, WRAP, () => {
            input()
            text("Search all vocabulary")
          })
        })
        container(MATCH, 0, () => {
          weight(1)
          scrollable()
          linear()
          Object.keys(PHRASES).forEach(letter => {
            container(WRAP, WRAP, () => {
              padding(16)
              text(letter)
            })
            container(MATCH, WRAP, () => {
              card()
              separator()
              linear()
              PHRASES[letter].forEach(phrase => {
                container(MATCH, WRAP, () => {
                  padding(16)
                  linear(8)
                  container(WRAP, WRAP, () => {
                    text(phrase.translation.english)
                  })
                  container(WRAP, WRAP, () => {
                    text(phrase.translation.mandarin)
                  })
                })
              })
            })
          })
        })
      })
    })
  })
  container(48, 48, () => {
    //fab()
    position(1, 1)
    anchor(1, 1)
  })

  //DRAWER
  container(MATCH, MATCH, () => {
    observe(drawer$, drawer => {
      if(drawer) {
        visibility(true)
      } else {
        if(this.firstRender) {
          visibility(false)
        } else {
          timeout(() => visibility(false), 300)
        }
      }
    })
    container(MATCH, MATCH, () => {
      background("rgba(0,0,0,.7)")
      observe(drawer$, drawer => {
        animateVisibility(drawer)
      })
      onClick(() => {
        drawer$.set(false)
      })
    })
    container(PERCENT(80), MATCH, () => {
      observe(drawer$, drawer => {
        const view = this.active
        if(drawer) {
          animate({
            x : -view.bounds.width
          }, {
            x : 0
          }, 300)
        } else {
          animate({
            x : 0
          }, {
            x : -view.bounds.width
          }, 300)
        }
      })
      background("white")
      linear()
      container(MATCH, WRAP, () => {
        padding(16)
        linear(8)
        background("#2196f3")
        container(PERCENT(40), WRAP, () => {
          src(languages_flag)
          position(.5, 0)
          anchor(.5, 0)
        })
        container(MATCH, WRAP, () => {
          text("Chinese - Mandarin")
          textAlign("center")
          textColor("white")
        })
      })
      container(MATCH, 0, () => {
        weight(1)
        scrollable()
        linear()
        MENU.forEach(item => {
          container(MATCH, WRAP, () => {
            onClick(item.onClick)
            padding(16)
            linear(16, "horizontal")
            container(WRAP, WRAP, () => {
              src(item.icon)
            })
            container(WRAP, WRAP, () => {
              text(item.text)
              position(0, .5)
              anchor(0, .5)
            })
          })
        })
      })
    })
  })
}

let screen
setTimeout(() => {
  screen = new Screen(document.getElementsByTagName("canvas")[0]).start(Overview);
})

</script>
</body>
</html>
