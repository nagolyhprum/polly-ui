<!doctype html>
<html>
<head>
  <style>
html,
body,
canvas,
input {
  padding: 0;
  border: 0;
  margin: 0;
}
input {
  background: transparent;
  color: transparent;
  outline: none;
  position : absolute;
  caret-color: black;
  font: 12px sans-serif;
}
  </style>
</head>
<body>
  <canvas width="375" height="667"></canvas>
<script>

const slight_round = 4
const EMPTY_ARRAY = [0, 0, 0, 0]
const COMPLEMENTARY_DIMENSIONS = {
  width : 'x',
  height : 'y',
  x : 'width',
  y : 'height'
}
const OPPOSITE_DIMENSIONS = {
  x : "y",
  y : "x",
  width : "height",
  height : "width"
}
const DIMENSIONS = {
  x : "width",
  y : "height",
  width : "height",
  height : "width"
}
const LINE_SPACING = 8

Array.prototype.contains = function(item) {
  return this.indexOf(item) !== -1
}

function svg(input) {
  const image = new Image()
  image.src = encodeURI(`data:image/svg+xml;,${input}`.replace(/\s+/g, ' '))
  return image
}

const sections_beginner = svg(`
  <svg height="24"
       width="24" viewBox="0 0 107 86" xmlns="http://www.w3.org/2000/svg">
      <path fill="#2196F3"
          d="M53.57,50.15l0,11.4l3.42,0l0,-11.4z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#BBDEFB"
          d="M80.86,19.34C77.18,19.34 74.2,16.36 74.2,12.69C74.2,9.45 76.53,6.75 79.61,6.16C80.92,2.57 84.38,0 88.43,0C92.45,0 95.87,2.51 97.21,6.04C97.22,6.04 97.22,6.04 97.22,6.04C100.9,6.04 103.88,9.02 103.88,12.69C103.88,16.16 101.22,19.01 97.82,19.31L97.82,19.34L80.86,19.34Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#BBDEFB"
          d="M6.97,39.79C3.29,39.79 0.3,36.81 0.3,33.14C0.3,29.9 2.63,27.19 5.71,26.61C7.03,23.02 10.48,20.45 14.54,20.45C18.55,20.45 21.98,22.96 23.32,26.49C23.32,26.49 23.32,26.49 23.32,26.49C27,26.49 29.98,29.47 29.98,33.14C29.98,36.61 27.32,39.46 23.93,39.76L23.93,39.79L6.97,39.79Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#BBDEFB"
          d="M53.57,5.7C53.57,5.7 43.52,15.08 36.47,28.49C29.44,42.85 25.08,54.71 25.08,54.71L53.57,54.71L53.57,5.7Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#2196F3"
          d="M53.57,5.7C53.57,5.7 60.51,21.84 66.11,31.91C72.08,42.41 84.34,56.99 84.34,56.99L53.57,56.99L53.57,5.7Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M21.2,78.7C21.2,78.7 22.68,84.34 27.93,84.34C33.17,84.34 35.27,78.7 35.27,78.7C35.27,78.7 37.23,84.34 42.51,84.34C47.79,84.34 49.64,78.7 49.64,78.7C49.64,78.7 50.91,84.34 56.66,84.34C62.42,84.34 63.91,78.7 63.91,78.7C63.91,78.7 65.78,84.34 71.12,84.34C76.46,84.34 78.09,78.7 78.09,78.7C78.09,78.7 79.93,84.34 85.2,84.34C90.47,84.34 92.08,78.7 92.08,78.7C92.08,78.7 93.07,84.34 98.94,84.34C104.81,84.34 105.53,79 105.53,78.7"
          stroke="#2196F3" stroke-linecap="round"
          stroke-linejoin="round" stroke-width="2"/>
      <path fill="#2196F3"
          d="M53.41,2.59L53.41,5.77L63.85,4.71C64.73,4.62 64.74,4.43 63.87,4.29L53.41,2.59Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#2196F3"
          d="M18.24,61.55L84.92,61.55C88.38,61.55 92.83,63.82 94.87,66.61L100.3,74.09L25.08,74.09L18.24,61.55Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M27.71,68.39L80.35,68.39"
          stroke="#BBDEFB" stroke-linecap="round" stroke-width="2"/>
      <path fill="#00000000"
          d="M83.89,68.39L86.01,68.39"
          stroke="#BBDEFB" stroke-linecap="round" stroke-width="2"/>
  </svg>
`)

const icons_back_white = svg(`
  <svg height="32" width="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path fill="#ffffff" d="M20,11H7.83l5.59,-5.59L12,4l-8,8 8,8 1.41,-1.41L7.83,13H20v-2z"/>
  </svg>
`)

const icons_menu = svg(`
  <svg height="32" width="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="white" d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
`)

const logos_lexicon_white = svg(`
  <svg width="117" height="114" viewBox="0 0 117 114" xmlns="http://www.w3.org/2000/svg">
      <path fill="#FFFFFF"
          d="M60.8,111.49C91.52,111.49 116.42,86.53 116.42,55.75C116.42,24.96 91.52,0 60.8,0C30.09,0 5.19,24.96 5.19,55.75C5.19,63.71 6.86,71.28 9.86,78.13C12.67,84.55 9.86,103.81 0,112.59C4.89,117.47 31.58,103.65 37.58,106.41C44.65,109.67 52.52,111.49 60.8,111.49Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#DCEFFD"
          d="M61,111C91.65,111 116.5,86.15 116.5,55.5C116.5,24.85 91.65,0 61,0"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#D8D8D8"
          d="M36,46.41a25.35,25.41 0,1 0,50.71 0a25.35,25.41 0,1 0,-50.71 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#2196F3"
          d="M47,46.94a13.9,13.94 0,1 0,27.81 0a13.9,13.94 0,1 0,-27.81 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#FFFFFF"
          d="M52,42.92a4.91,4.92 0,1 0,9.81 0a4.91,4.92 0,1 0,-9.81 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M42,85C47.49,88.94 54.22,91.26 61.49,91.26L61.49,91.26C68.12,91.26 74.31,89.33 79.51,86"
          stroke="#2196F3" stroke-linecap="round"
          stroke-linejoin="round" stroke-width="3"/>
  </svg>`
)

const languages_flag = svg(`
  <svg height="24"
       width="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
      <path fill="#F3625B"
          d="M0,16a16,16 0,1 0,32 0a16,16 0,1 0,-32 0z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#FFC400"
          d="M16,21.27l-5.56,2.73l1.06,-5.79l-4.5,-4.1l6.22,-0.84l2.78,-5.27l2.78,5.27l6.22,0.84l-4.5,4.1l1.06,5.79z"
          stroke="#00000000" stroke-width="1"/>
      <path fill-opacity="0.2" fill="#000000"
          d="M16,32C24.84,32 32,24.84 32,16C32,7.16 24.84,0 16,0"
          stroke-opacity="0.2" stroke="#00000000" stroke-width="1"/>
  </svg>
`)

const streak_normal = svg(`
  <svg height="24"
       width="24" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
      <path fill="#FFFFFF"
          d="M8.877,13.763C11.018,13.763 12.754,12.059 12.754,9.956C12.754,8.805 12.234,7.773 11.412,7.075C9.212,6.036 9.031,4.96 9.031,4.038C8.403,4.713 6.991,5.556 6.991,8.92C6.991,8.92 6.299,8.577 6.167,7.233C5.713,7.668 5,8.889 5,9.956C5,12.059 6.736,13.763 8.877,13.763Z"
          stroke="#00000000" stroke-width="1"/>
      <path fill="#00000000"
          d="M9,9m-8,0a8,8 0,1 1,16 0a8,8 0,1 1,-16 0"
          stroke="#FFFFFF" stroke-width="1"/>
  </svg>
`)

function equals(a, b) {
  if(a === b) {
    return true
  }
  for(var i in a) {
    if(a[i] !== b[i]) {
      return false
    }
  }
  for(var i in b) {
    if(a[i] !== b[i]) {
      return false
    }
  }
  return true
}

function roundRect(context, x, y, width, height, radius, fill, stroke) {
  radius = { tl: radius, tr: radius, br: radius, bl: radius };
  context.beginPath();
  context.moveTo(x + radius.tl, y);
  context.lineTo(x + width - radius.tr, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  context.lineTo(x + width, y + height - radius.br);
  context.quadraticCurveTo(
    x + width,
    y + height,
    x + width - radius.br,
    y + height
  );
  context.lineTo(x + radius.bl, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  context.lineTo(x, y + radius.tl);
  context.quadraticCurveTo(x, y, x + radius.tl, y);
  context.closePath();
  if(fill) {
    context.fillStyle = fill;
    context.fill();
  }
  if(stroke) {
    context.strokeStyle = stroke;
    context.stroke();
  }
}

const getValue = (view, dim) => {
  if (typeof view[dim] === "function") {
    return view[dim](view, dim);
  } else {
    return view[dim];
  }
};

const getTopBottom = r => {
  return r instanceof Array ? r[0] + r[2] : 0;
};

const getLeftRight = r => {
  return r instanceof Array ? r[1] + r[3] : 0;
};

const getName = view => view.text.display || view.image || `(${view.children.map(getName)})`;

const reposition = view => {
  const padding = view.parent.padding instanceof Array ? view.parent.padding : EMPTY_ARRAY
  const margin = view.parent.margin instanceof Array ? view.parent.margin : EMPTY_ARRAY
  return {
    x : view.parent.bounds.x + padding[3] + margin[3] + view.x + (view.parent.scrollX || 0),
    y : view.parent.bounds.y + padding[0] + margin[0] + view.y + (view.parent.scrollY || 0)
  }
}

function Screen(canvas) {
  this.children = [];
  this.active = this;
  this.canvas = canvas;
  this.bounds = { x : 0, y : 0, width : canvas.width, height : canvas.height}
  this.context = canvas.getContext("2d");
  this.bind();

  const getMouse = (e, name) => {
    const bounds = canvas.getBoundingClientRect();
    return {
      x : e.pageX - bounds.left,
      y : e.pageY - bounds.top,
      name
    }
  }

  this.last = []
  const call = (e, name) => {
    const mouse = getMouse(e, name)
    const mouseOver = this.mouseOver(mouse, this);
    this.last.forEach(view => {
      if(!mouseOver.contains(view)) {
        view.onMouseOut && view.onMouseOut(getMouse(e, "onMouseOut"))
      }
    })
    mouseOver.forEach(view => {
      if(!this.last.contains(view)) {
        view.onMouseIn && view.onMouseIn(getMouse(e, "onMouseIn"))
      }
    })
    this.last = mouseOver
    let view = mouseOver[mouseOver.length - 1]
    while (view && !view[name]) {
      view = view.parent;
    }
    if(view && view !== this) {
      view[name](mouse)
    }
  }

  let moved
  canvas.onmousedown = e => {
    moved = 0
    call(e, "onMouseDown")
  }

  canvas.onmousemove = e => {
    moved++
    call(e, "onMouseMove")
  }

  canvas.onmouseup = e => {
    call(e, "onMouseUp")
  }

  canvas.onclick = e => {
    if(moved < 5) {
      call(e, "onClick")
    }
  };
}

Screen.prototype = {
  mouseOver(mouse, view) {
    return view.children.reduce((mouseOver, child) => {
      const {
        x,
        y,
        width,
        height
      } = child.bounds
      const margin = child.margin || EMPTY_ARRAY
      roundRect(
        this.context,
        x + margin[3],
        y + margin[0],
        width - getLeftRight(margin),
        height - getTopBottom(margin),
        getValue(child, "round")
      );
      if (child.isInBounds && this.context.isPointInPath(mouse.x, mouse.y)) {
        return mouseOver.concat([child]).concat(this.mouseOver(mouse, child))
      }
      return mouseOver
    }, [])
  },
  PERCENT(percent) {
    return dim => view => {
      const vp = this.getViewPortSize(view.parent)
      return {
        [dim] : vp[OPPOSITE_DIMENSIONS[DIMENSIONS[dim]]] * percent / 100
      }
    }
  },
  MATCH(dim) {
    return view => {
      const vp = this.getViewPortSize(view.parent)
      switch(dim) {
        case "width" :
           return {
             width : vp.width
           }
        case "height" :
           return {
             height : vp.height
           }
      }
    }
  },
  WRAP: (function() {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    return dim => view => {
      const spaceAround = {
        width : getLeftRight(view.padding) + getLeftRight(view.margin),
        height : getTopBottom(view.padding) + getTopBottom(view.margin)
      }[dim]
      if(view.image) {
        const imageBounds = {
          width : view.image.width || view.image.naturalWidth,
          height : view.image.height || view.image.naturalHeight
        }
        const other = OPPOSITE_DIMENSIONS[dim]
        const opposite = (view.bounds[other] / imageBounds[other]) * imageBounds[dim]
        return {
          [dim] : opposite || view.image[dim] + spaceAround
        }
      } else if (view.children.length) {
        return {
          [dim] : Math.max(...view.children.map(
            child =>
              child[COMPLEMENTARY_DIMENSIONS[dim]] + //child.x
              //child.bounds[COMPLEMENTARY_DIMENSIONS[dim]] + //child.bounds.x
              child.bounds[dim] + //child.bounds.width
              spaceAround
          ))
        }
      } else if (view.text.display || view.input) {
        if (dim === "width") {
          context.font = `${view.text.size}px sans-serif`;
          return {
            width : Math.max(...view.text.display.split("\n").map(display => context.measureText(display).width)) + spaceAround
          }
        } else if (dim === "height") {
          const count = view.text.display.split("\n").length
          return {
            height : (
              view.text.size * count + LINE_SPACING * (count - 1) + spaceAround
            )
          }
        }
      }
      return {
        [dim] : spaceAround
      }
    };
  })(),
  container(width, height, render) {
    const parent = this.active;
    const child = {
      round : 0,
      //margin
      //padding
      //background
      //onClick
      managers : [
        typeof width === "function" ? width("width") : () => ({ width }),
        typeof height === "function" ? height("height") : () => ({ height }),
        reposition
      ],
      overflow : true,
      parent,
      alpha : 1,
      x : 0,
      y : 0,
      width : 0,
      height : 0,
      bounds : {
        x : 0,
        y : 0,
        width : 0,
        height : 0
      },
      scrollX : 0,
      scrollY : 0,
      children: [],
      text: {
        //display
        size: 12,
        color: "black",
        weight : 'normal',
        align : "left"
      }
    };
    parent.children.push(child);
    this.active = child;
    render();
    this.active = parent;
  },
  style(text) {
    if(text.size) {
      this.active.text.size = text.size
    }
  },
  anchor(x, y) {
    this.active.managers.push(view => ({
      x : -Math.max(view.bounds.width, 0) * x,
      y : -Math.max(view.bounds.height, 0) * y
    }))
  },
  getViewPortSize(view) {
    return {
      width : view.bounds.width - getLeftRight(view.padding) - getLeftRight(view.margin),
      height : view.bounds.height - getTopBottom(view.padding) - getTopBottom(view.margin)
    }
  },
  position(x, y) {
    this.active.managers.push(view => {
      const vp = this.getViewPortSize(view.parent)
      return {
        x : vp.width * x,
        y : vp.height * y
      }
    })
  },
  margin(...margin) {
    if(margin.length === 1) {
      this.active.margin = [margin[0], margin[0], margin[0], margin[0]]
    } else {
      this.active.margin = margin;
    }
  },
  padding(...padding) {
    if(padding.length === 1) {
      this.active.padding = [padding[0], padding[0], padding[0], padding[0]]
    } else {
      this.active.padding = padding;
    }
  },
  background(background) {
    this.active.background = background;
  },
  onClick(onClick) {
    this.active.onClick = onClick;
  },
  text(display) {
    this.active.text.display = display;
  },
  round(round) {
    this.active.round = round;
  },
  shadow(shadow = true) {
    this.active.shadow = shadow;
  },
  src(image) {
    this.active.image = image;
  },
  textColor(textColor) {
    this.active.text.color = textColor
  },
  textAlign(align) {
    this.active.text.align = align
  },
  input(input = "text") {
    const view = this.active
    view.input = input
    view.onClick = () => {
      this.textbox = this.textbox || document.createElement("input")
      this.textbox.style.display = "block"
      this.textbox.oninput = null
      this.textbox.onblur = null
      this.textbox.value = view.text.display
      if(!this.textbox.parentNode) {
        document.body.appendChild(this.textbox)
      }
      this.textbox.style.left = `${view.bounds.x}px`
      this.textbox.style.top = `${view.bounds.y}px`
      this.textbox.style.width = `${view.bounds.width}px`
      this.textbox.style.height = `${view.bounds.height}px`
      this.textbox.type = input
      this.textbox.focus()
      this.textbox.onblur = e => {
        this.textbox.style.display = "none"
      }
      this.textbox.oninput = e => {
        view.text.display = this.textbox.value
        this.render()
      }
    }
  },
  animate(child, from, to, ms, cb) {
    const start = Date.now()
    const handler = (now = Date.now()) => {
      const percent =  Math.min((now - start) / ms, 1)
      const weight = percent
      Object.keys(from).forEach(key => {
        child[key] = from[key] + (to[key] - from[key]) * weight
      })
      if(percent === 1) {
        clearInterval(interval)
        cb && cb()
      }
      this.render()
    }
    handler(start)
    const interval = setInterval(handler, 1000 / 60)
  },
  start(view, state) {
    this.container(this.MATCH, this.MATCH, () => {
      this.background("white")
      view.call(this, state)
    })
    if(this.children.length > 1) {
      this.animate(this.children[this.children.length - 1], {
        alpha : .25,
        x : this.bounds.width
      }, {
        alpha : 1,
        x : 0
      }, 300)
    } else {
      this.render()
    }
    return this
  },
  back() {
    if(this.children.length > 1) {
      this.animate(this.children[this.children.length - 1], {
        alpha : 1,
        x : 0
      }, {
        alpha : .25,
        x : this.bounds.width
      }, 300, () => {
        this.children.pop()
      })
    } else {
      console.log("TODO")
    }
  },
  separator() {
    this.active.separator = true
  },
  linear(spacing = 0, direction = 'vertical') {
    this.active.managers.unshift(view => {
      const weight = view.children.reduce((weight, child) => weight + (child.weight || 0), 0)
      if(weight) {
        const dim = direction === "vertical" ? "height" : "width"
        const vp = this.getViewPortSize(view)
        const span = view.bounds[dim]
        const space = view.children.reduce((space, child) => {
          return space - (child.weight ? 0 : child.bounds[dim])
        }, vp[dim] - spacing * (view.children.length - 1))
        view.children.forEach(child => {
          if(child.weight) {
            child[dim] = (child.weight / weight) * space
          }
        })
      }
      view.children.forEach((child, index) => {
        if(index) {
          const previous = view.children[index - 1]
          if(direction === 'vertical') {
            child.y = previous.y + previous.bounds.height + spacing
          } else if(direction === 'horizontal') {
            child.x = previous.x + previous.bounds.width + spacing
          }
        }
        this.layoutView(child)
      })
      return {}
    })
  },
  weight(weight) {
    this.active.weight = weight
  },
  render() {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
    return this.children.forEach(child => {
      this.layoutView(child)
      this.renderView(child)
    });
  },
  scrollable() {
    const active = this.active
    active.overflow = false
    let lastMouse, lastTs = Date.now(), dx = 0, dy = 0
    setInterval(() => {
      const now = Date.now()
      const dt = (now - lastTs) / 1000
      lastTs = now
      dx /= 1.2
      if(Math.abs(dx) < 1) {
        dx = 0
      }
      dy /= 1.2
      if(Math.abs(dy) < 1) {
        dy = 0
      }
      if(!lastMouse && (dx || dy)) {
        update()
      }
    }, 1000 / 60)
    const update = () => {
      const right = Math.max(...active.children.map(child => child.bounds.x + child.bounds.width)) - (active.bounds.x + active.bounds.width + active.scrollX)
      const bottom = Math.max(...active.children.map(child => child.bounds.y + child.bounds.height)) - (active.bounds.y + active.bounds.height + active.scrollY)
      active.scrollX = Math.max(Math.min(active.scrollX + dx, 0), -right)
      active.scrollY = Math.max(Math.min(active.scrollY + dy, 0), -bottom)
      this.render()
    }
    active.onMouseMove = function(mouse) {
      if(lastMouse) {
        dx = mouse.x - lastMouse.x
        dy = mouse.y - lastMouse.y
        update()
        lastMouse = mouse
      }
    }
    active.onMouseDown = function(mouse) {
      lastMouse = mouse
    }
    active.onMouseUp = active.onMouseOut = function(mouse) {
      lastMouse = null
    }
  },
  getIntersection(view) {
    const parent = view.parent
    const intersection = {
      left : Math.max(parent.bounds.x, view.bounds.x),
      top : Math.max(parent.bounds.y, view.bounds.y)
    }
    intersection.right = Math.min(parent.bounds.x + parent.bounds.width, view.bounds.x + view.bounds.width)
    intersection.bottom = Math.min(parent.bounds.y + parent.bounds.height, view.bounds.y + view.bounds.height)
    view.intersection = intersection
    //then check if its in bounds
    view.isInBounds = intersection.bottom - intersection.top > 0 && intersection.right - intersection.left > 0
  },
  layoutView(view) {
    const bounds = view.managers.reduce((bounds, manager) => {
      const wrapper = manager(view)
      const current = typeof wrapper === "function" ? wrapper(view) : wrapper
      return {
        x : Math.round((current.x || 0) + bounds.x),
        y : Math.round((current.y || 0) + bounds.y),
        width : Math.round((current.width || 0) + bounds.width),
        height : Math.round((current.height || 0) + bounds.height)
      }
    }, {
      x : 0,
      y : 0,
      width : view.width,
      height : view.height
    })
    //TODO call dependents
    if(!equals(view.bounds, bounds)) {
      view.bounds = bounds
      if(view.children.length) {
        view.children.forEach(this.layoutView)
      }
      this.layoutView(view)
    }
    this.getIntersection(view)
  },
  renderView(view) {
    if(!view.hidden && view.isInBounds) {
      this.context.save()
      this.context.globalAlpha = this.context.globalAlpha * view.alpha
      const x = view.bounds.x
      const y = view.bounds.y
      const width = view.bounds.width
      const height = view.bounds.height
      const hw = width / 2
      const hh = height / 2
      const margin = view.margin || EMPTY_ARRAY
      const padding = view.padding || EMPTY_ARRAY
      const mw = width - getLeftRight(margin);
      const mh = height - getTopBottom(margin);

      if(view.shadow) {
        const shadow = 2
        this.context.shadowColor = 'rgba(0, 0, 0, .7)';
        this.context.shadowBlur = shadow;
        this.context.shadowOffsetX = shadow;
        this.context.shadowOffsetY = shadow;
      }
      roundRect(
        this.context,
        x + margin[3],
        y + margin[0],
        mw,
        mh,
        getValue(view, "round"),
        view.background || "transparent"
      );
      this.context.shadowColor = 'transparent';
      this.context.shadowBlur = 0;
      this.context.shadowOffsetX = 0;
      this.context.shadowOffsetY = 0;
      //DEBUG HERE
      if(true) {
        this.context.translate(x, y)
        //padding
        if(padding) {
          this.context.fillStyle = "rgba(0, 255, 0, .7)"
          //top
          this.context.fillRect(margin[3], margin[0], width - (margin[3] + margin[1]), padding[0])
          //left
          this.context.fillRect(margin[3], margin[0] + padding[0], padding[3], height - (margin[0] + margin[2] + padding[0]))
          //right
          this.context.fillRect(width - margin[1] - padding[1], margin[0] + padding[0], padding[1], height - (margin[0] + margin[2] + padding[0]))
          //bottom
          this.context.fillRect(margin[3] + padding[3], height - margin[2] - padding[2], width - (margin[3] + padding[3] + margin[1] + padding[1]), padding[2])
        }
        //margin
        if(margin) {
          this.context.fillStyle = "rgba(0, 0, 255, .7)"
          //top
          this.context.fillRect(0, 0, width, margin[0])
          //left
          this.context.fillRect(0, margin[0], margin[3], height - margin[0])
          //right
          this.context.fillRect(width - margin[1], margin[0], margin[1], height - margin[0])
          //bottom
          this.context.fillRect(margin[3], height - margin[2], width - margin[1] - margin[3], margin[2])
        }
        //outline
        this.context.strokeStyle = "rgba(255, 255, 255, .7)"
        this.context.setLineDash([2, 4])
        this.context.strokeRect(0, 0, width, height)
        this.context.setLineDash([])
        this.context.translate(-x, -y)
      }
      if(view.image && view.image.complete) {
        this.context.drawImage(view.image, x, y, mw - getLeftRight(padding), mh - getTopBottom(padding))
      }
      //STOP DEBUG
      if(!view.overflow) {
        this.context.clip()
      }
      if (view.text.display) {
        this.context.fillStyle = view.text.color;
        this.context.font = `${view.text.size}px sans-serif`;
        this.context.textBaseline = "top";
        this.context.textAlign = view.text.align;
        const lines = view.text.display.split("\n")
        lines.forEach((line, index) => {
          let offsetX = 0
          switch(this.context.textAlign) {
            case "right" : offsetX = width - getLeftRight(padding); break;
            case "center" : offsetX = mw / 2 - padding[3]; break;
          }
          // \u25CF
          // \u2022
          this.context.fillText(
            view.input === "password" ? line.split("").map(it => '\u2022').join("") : line,
            x + offsetX + padding[3],
            y + index * (view.text.size + LINE_SPACING) + padding[0]
          );
        })
      }
      view.children.forEach((child, index) => {
        this.renderView(child)
        if(index > 0 && view.separator) {
          this.context.beginPath()
          this.context.moveTo(
            child.bounds.x,
            child.bounds.y
          )
          this.context.lineTo(
            child.bounds.x + child.bounds.width,
            child.bounds.y
          )
          this.context.strokeStyle = "rgba(0, 0, 0, .7)"
          this.context.stroke()
        }
      });
      this.context.globalAlpha = this.context.globalAlpha / view.alpha
      this.context.restore()
    }
  },
  button(color) {
    this.textAlign("center")
    this.padding(16)
    this.textColor("white")
    if(color) {
      this.round(child => Math.min(child.bounds.width / 2, child.bounds.height / 2))
      this.background(color)
    }
  },
  card() {
    this.background("white")
    this.round(slight_round)
    this.shadow()
  },
  bind() {
    for (var i in this) {
      if (typeof this[i] === "function") {
        this[i] = this[i].bind(this);
      }
    }
  }
};

const normal_12 = {
  size : 12
}
const medium_20 = {
  weight : "medium",
  size : 20
}
const bold_34 = {
  weight : "bold",
  size : 34
}
const bold_20 = {
  weight : "bold",
  size : 20
}

const Splash = function (state) {
  const {
    container,
    background,
    padding,
    position,
    text,
    round,
    onClick,
    anchor,
    start,
    src,
    style,
    linear,
    textColor,
    WRAP,
    MATCH,
    PERCENT,
    textAlign,
    button
  } = this;
  background("#2196f3")
  container(PERCENT(40), WRAP, () => {
    anchor(.5, .5)
    position(.5, .25)
    src(logos_lexicon_white)
  })
  container(WRAP, WRAP, () => {
    linear(16)
    anchor(.5, .5)
    position(.5, .5)
    container(WRAP, WRAP, () => {
      anchor(.5, 0)
      position(.5, 0)
      textColor("white")
      text("Lexicon")
      style(bold_34)
    })
    container(WRAP, WRAP, () => {
      text("Your language learning buddy")
      textColor("white")
      style(bold_20)
    })
  })
  container(PERCENT(50), WRAP, () => {
    linear(16)
    anchor(.5, .5)
    position(.5, .75)
    container(MATCH, WRAP, () => {
      button("#673ab7")
      text("GET STARTED")
      onClick(() => {
        start(LanguagePicker, state)
      })
    })
    container(MATCH, WRAP, () => {
      text("LOGIN")
      button()
      onClick(() => {
        start(Login)
      })
    })
  })
}

const LANGUAGES = Array.from({ length : 32 }).map((_, i) => ({
  flag : languages_flag,
  display : "Chinese - Mandarin " + (i + 1)
}))

const LanguagePicker = function(state) {
  const {
    round,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    MATCH,
    textColor,
    start,
    textAlign,
    weight,
    button,
    card,
    separator
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    container(MATCH, WRAP, () => {
      textColor("white")
      text("What language do\nyou speak natively?")
      textAlign("center")
      style(medium_20)
    })
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, .5)
      onClick(back)
    })
  })
  container(MATCH, 0, () => {
    weight(1)
    card()
    linear()
    scrollable()
    separator()
    LANGUAGES.forEach((language, index) => {
      container(MATCH, WRAP, () => {
        onClick(() => {
          start(GoalPicker, {})
        })
        padding(16)
        linear(16, "horizontal")
        container(WRAP, WRAP, () => {
          src(language.flag)
        })
        container(WRAP, WRAP, () => {
          text(language.display)
          anchor(0, .5)
          position(0, .5)
        })
      })
    })
  })
  container(WRAP, WRAP, () => {
    text("REQUEST A LANGUAGE")
    button()
    anchor(1, 0)
    position(1, 0)
  })
}

const GOALS = [{
  months : 15,
  words : 3
}, {
  months : 10,
  words : 6
}, {
  months : 5,
  words : 9
}]

const GoalPicker = function(state) {
  const {
    start,
    round,
    margin,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    PERCENT,
    WRAP,
    MATCH,
    textColor,
    textAlign,
    card,
    separator
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    container(MATCH, WRAP, () => {
      textColor("white")
      text("How quickly would you\nlike to learn?")
      textAlign("center")
      anchor(0, .5)
      position(0, .5)
      style(medium_20)
    })
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, .5)
      onClick(back)
    })
  })
  container(PERCENT(40), WRAP, () => {
    src(languages_flag)
    position(.5, 0)
    anchor(.5, 0)
  })
  container(WRAP, WRAP, () => {
    text("Chinese (Mandarin)")
    textColor("white")
    position(.5, 0)
    anchor(.5, 0)
  })
  container(MATCH, WRAP, () => {
    card()
    linear()
    separator()
    GOALS.forEach(goal => {
      container(MATCH, WRAP, () => {
        padding(16)
        linear(8)
        container(WRAP, WRAP, () => {
          text(`I want to be conversational in ${goal.months} months`)
        })
        container(WRAP, WRAP, () => {
          text(`${goal.words} words per day`)
        })
        onClick(() => {
          start(Overview)
        })
      })
    })
  })
}

const Login = function(state) {
  const {
    round,
    margin,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    MATCH,
    textColor,
    textAlign,
    input,
    button,
    card,
    start
  } = this
  padding(16)
  background("#2196f3")
  linear(16)
  container(MATCH, WRAP, () => {
    linear(16, "horizontal")
    container(WRAP, WRAP, () => {
      src(icons_back_white)
      anchor(0, .5)
      position(0, .5)
      onClick(back)
    })
    container(WRAP, WRAP, () => {
      textColor("white")
      text("Login")
      anchor(0, .5)
      position(0, .5)
      style(medium_20)
    })
  })
  container(MATCH, WRAP, () => {
    card()
    padding(16)
    linear(16)
    container(MATCH, WRAP, () => {
      text("Username")
      input()
    })
    container(MATCH, WRAP, () => {
      text("Password")
      input("password")
    })
    container(MATCH, WRAP, () => {
      text("Login")
      button("#673ab7")
      onClick(() => {
        start(Overview)
      })
    })
    container(MATCH, WRAP, () => {
      container(MATCH, 1, () => {
        position(0, .5)
        anchor(0, .5)
        background("black")
      })
      container(WRAP, WRAP, () => {
        position(.5, 0)
        anchor(.5, 0)
        text("OR")
        background("white")
        padding(0, 16, 0, 16)
      })
    })
    container(MATCH, WRAP, () => {
      text("CONNECT WITH GOOGLE")
      button("#673ab7")
      onClick(() => {
        start(Overview)
      })
    })
    container(MATCH, WRAP, () => {
      button("#673ab7")
      text("CONNECT WITH FACEBOOK")
      onClick(() => {
        start(Overview)
      })
    })
  })
}

const SECTIONS = [{
  icon : sections_beginner,
  name : "Beginner"
}, {
  icon : sections_beginner,
  name : "Beginner"
}, {
  icon : sections_beginner,
  name : "Beginner"
}]

const Overview = function(state) {
  const {
    round,
    margin,
    background,
    padding,
    container,
    src,
    linear,
    text,
    anchor,
    position,
    style,
    shadow,
    back,
    onClick,
    scrollable,
    WRAP,
    MATCH,
    PERCENT,
    textColor,
    textAlign,
    input,
    button,
    card,
    weight
  } = this
  background("#2196f3")
  linear(0)
  container(MATCH, WRAP, () => {
    padding(16, 16, 0, 16)
    linear(8, "horizontal")
    container(WRAP, WRAP, () => {
      src(icons_menu)
    })
    container(0, WRAP, () => {
      position(0, .5)
      anchor(0, .5)
      weight(1)
      textColor("white")
      text("Chinese - Mandarin")
      style(medium_20)
    })
    container(WRAP, PERCENT(50), () => {
      src(languages_flag)
      position(0, .5)
      anchor(0, .5)
    })
    container(WRAP, WRAP, () => {
      position(0, .5)
      anchor(0, .5)
      textColor("white")
      text("100%")
      style(normal_12)
    })
    container(WRAP, PERCENT(50), () => {
      src(streak_normal)
      position(0, .5)
      anchor(0, .5)
    })
    container(WRAP, WRAP, () => {
      position(0, .5)
      anchor(0, .5)
      textColor("white")
      text("1")
      style(normal_12)
    })
  })
  container(MATCH, WRAP, () => {
    linear(0, "horizontal")
    container(0, WRAP, () => {
      textColor("white")
      padding(16)
      weight(1)
      text("LEARN")
      style(normal_12)
      textAlign("center")
    })
    container(0, WRAP, () => {
      textColor("white")
      padding(16)
      weight(1)
      text("LEARN")
      style(normal_12)
      textAlign("center")
    })
  })
  container(MATCH, 0, () => {
    weight(1)
    linear()
    scrollable()
    background('#f1f9ff')
    SECTIONS.forEach(section => {
      container(MATCH, WRAP, () => {
        padding(16)
        linear(8)
        container(PERCENT(25), WRAP, () => {
          position(.5, 0)
          anchor(.5, 0)
          src(section.icon)
        })
        container(WRAP, WRAP, () => {
          position(.5, 0)
          anchor(.5, 0)
          text(section.name)
        })
      })
      container(MATCH, 100, () => {
        card()
      })
    })
  })
}

let screen
setTimeout(() => {
  screen = new Screen(document.getElementsByTagName("canvas")[0]).start(Overview);
})

</script>
</body>
</html>
